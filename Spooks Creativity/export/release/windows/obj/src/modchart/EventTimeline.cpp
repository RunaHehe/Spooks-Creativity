// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_modchart_EventTimeline
#include <modchart/EventTimeline.h>
#endif
#ifndef INCLUDED_modchart_events_BaseEvent
#include <modchart/events/BaseEvent.h>
#endif
#ifndef INCLUDED_modchart_events_ModEvent
#include <modchart/events/ModEvent.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_646cacc80a2d7320_6_new,"modchart.EventTimeline","new",0xde7510fb,"modchart.EventTimeline.new","modchart/EventTimeline.hx",6,0x34bd38d6)
HX_LOCAL_STACK_FRAME(_hx_pos_646cacc80a2d7320_12_addMod,"modchart.EventTimeline","addMod",0x3f9ef966,"modchart.EventTimeline.addMod","modchart/EventTimeline.hx",12,0x34bd38d6)
HX_LOCAL_STACK_FRAME(_hx_pos_646cacc80a2d7320_16_addEvent,"modchart.EventTimeline","addEvent",0x09c99bbe,"modchart.EventTimeline.addEvent","modchart/EventTimeline.hx",16,0x34bd38d6)
HX_LOCAL_STACK_FRAME(_hx_pos_646cacc80a2d7320_25_addEvent,"modchart.EventTimeline","addEvent",0x09c99bbe,"modchart.EventTimeline.addEvent","modchart/EventTimeline.hx",25,0x34bd38d6)
HX_LOCAL_STACK_FRAME(_hx_pos_646cacc80a2d7320_30_addEvent,"modchart.EventTimeline","addEvent",0x09c99bbe,"modchart.EventTimeline.addEvent","modchart/EventTimeline.hx",30,0x34bd38d6)
HX_LOCAL_STACK_FRAME(_hx_pos_646cacc80a2d7320_35_update,"modchart.EventTimeline","update",0x27a0584e,"modchart.EventTimeline.update","modchart/EventTimeline.hx",35,0x34bd38d6)
namespace modchart{

void EventTimeline_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_646cacc80a2d7320_6_new)
HXLINE(   8)		this->events = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(   7)		this->modEvents =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}

Dynamic EventTimeline_obj::__CreateEmpty() { return new EventTimeline_obj; }

void *EventTimeline_obj::_hx_vtable = 0;

Dynamic EventTimeline_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< EventTimeline_obj > _hx_result = new EventTimeline_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool EventTimeline_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x29c142db;
}

void EventTimeline_obj::addMod(::String modName){
            	HX_STACKFRAME(&_hx_pos_646cacc80a2d7320_12_addMod)
HXDLIN(  12)		this->modEvents->set(modName,::Array_obj< ::Dynamic>::__new(0));
            	}


HX_DEFINE_DYNAMIC_FUNC1(EventTimeline_obj,addMod,(void))

void EventTimeline_obj::addEvent( ::modchart::events::BaseEvent event){
            	HX_STACKFRAME(&_hx_pos_646cacc80a2d7320_16_addEvent)
HXDLIN(  16)		if (::Std_obj::isOfType(event,::hx::ClassOf< ::modchart::events::ModEvent >())) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            			int _hx_run( ::modchart::events::ModEvent a, ::modchart::events::ModEvent b){
            				HX_STACKFRAME(&_hx_pos_646cacc80a2d7320_25_addEvent)
HXLINE(  25)				return ::Std_obj::_hx_int((a->executionStep - b->executionStep));
            			}
            			HX_END_LOCAL_FUNC2(return)

HXLINE(  17)			 ::modchart::events::ModEvent modEvent = ( ( ::modchart::events::ModEvent)(event) );
HXLINE(  18)			::String name = modEvent->modName;
HXLINE(  19)			if (!(this->modEvents->exists(name))) {
HXLINE(  20)				this->addMod(name);
            			}
HXLINE(  22)			if (!(( (::Array< ::Dynamic>)(this->modEvents->get(name)) )->contains(modEvent))) {
HXLINE(  23)				( (::Array< ::Dynamic>)(this->modEvents->get(name)) )->push(modEvent);
            			}
HXLINE(  25)			( (::Array< ::Dynamic>)(this->modEvents->get(name)) )->sort( ::Dynamic(new _hx_Closure_0()));
            		}
            		else {
HXLINE(  28)			if (!(this->events->contains(event))) {
            				HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(2)
            				int _hx_run( ::modchart::events::BaseEvent a, ::modchart::events::BaseEvent b){
            					HX_STACKFRAME(&_hx_pos_646cacc80a2d7320_30_addEvent)
HXLINE(  30)					return ::Std_obj::_hx_int((a->executionStep - b->executionStep));
            				}
            				HX_END_LOCAL_FUNC2(return)

HXLINE(  29)				this->events->push(event);
HXLINE(  30)				this->events->sort( ::Dynamic(new _hx_Closure_1()));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(EventTimeline_obj,addEvent,(void))

void EventTimeline_obj::update(Float step){
            	HX_STACKFRAME(&_hx_pos_646cacc80a2d7320_35_update)
HXLINE(  36)		{
HXLINE(  36)			 ::Dynamic modName = this->modEvents->keys();
HXDLIN(  36)			while(( (bool)(modName->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  36)				::String modName1 = ( (::String)(modName->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  37)				::Array< ::Dynamic> garbage = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  38)				::Array< ::Dynamic> schedule = ( (::Array< ::Dynamic>)(this->modEvents->get(modName1)) );
HXLINE(  39)				{
HXLINE(  39)					int _g = 0;
HXDLIN(  39)					while((_g < schedule->length)){
HXLINE(  39)						 ::modchart::events::ModEvent event = schedule->__get(_g).StaticCast<  ::modchart::events::ModEvent >();
HXDLIN(  39)						_g = (_g + 1);
HXLINE(  40)						if (event->finished) {
HXLINE(  41)							garbage->push(event);
            						}
HXLINE(  44)						bool _hx_tmp;
HXDLIN(  44)						if (!(event->ignoreExecution)) {
HXLINE(  44)							_hx_tmp = event->finished;
            						}
            						else {
HXLINE(  44)							_hx_tmp = true;
            						}
HXDLIN(  44)						if (_hx_tmp) {
HXLINE(  45)							continue;
            						}
HXLINE(  47)						if ((step >= event->executionStep)) {
HXLINE(  48)							event->run(step);
            						}
            						else {
HXLINE(  50)							goto _hx_goto_6;
            						}
HXLINE(  52)						if (event->finished) {
HXLINE(  53)							garbage->push(event);
            						}
            					}
            					_hx_goto_6:;
            				}
HXLINE(  56)				{
HXLINE(  56)					int _g1 = 0;
HXDLIN(  56)					while((_g1 < garbage->length)){
HXLINE(  56)						 ::modchart::events::ModEvent trash = garbage->__get(_g1).StaticCast<  ::modchart::events::ModEvent >();
HXDLIN(  56)						_g1 = (_g1 + 1);
HXLINE(  57)						schedule->remove(trash);
            					}
            				}
            			}
            		}
HXLINE(  60)		::Array< ::Dynamic> garbage1 = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  61)		{
HXLINE(  61)			int _g2 = 0;
HXDLIN(  61)			::Array< ::Dynamic> _g3 = this->events;
HXDLIN(  61)			while((_g2 < _g3->length)){
HXLINE(  61)				 ::modchart::events::BaseEvent event1 = _g3->__get(_g2).StaticCast<  ::modchart::events::BaseEvent >();
HXDLIN(  61)				_g2 = (_g2 + 1);
HXLINE(  63)				if (event1->finished) {
HXLINE(  64)					garbage1->push(event1);
            				}
HXLINE(  66)				bool _hx_tmp1;
HXDLIN(  66)				if (!(event1->ignoreExecution)) {
HXLINE(  66)					_hx_tmp1 = event1->finished;
            				}
            				else {
HXLINE(  66)					_hx_tmp1 = true;
            				}
HXDLIN(  66)				if (_hx_tmp1) {
HXLINE(  67)					continue;
            				}
HXLINE(  70)				if ((step >= event1->executionStep)) {
HXLINE(  71)					event1->run(step);
            				}
            				else {
HXLINE(  73)					goto _hx_goto_8;
            				}
HXLINE(  75)				if (event1->finished) {
HXLINE(  76)					garbage1->push(event1);
            				}
            			}
            			_hx_goto_8:;
            		}
HXLINE(  79)		{
HXLINE(  79)			int _g4 = 0;
HXDLIN(  79)			while((_g4 < garbage1->length)){
HXLINE(  79)				 ::modchart::events::BaseEvent trash1 = garbage1->__get(_g4).StaticCast<  ::modchart::events::BaseEvent >();
HXDLIN(  79)				_g4 = (_g4 + 1);
HXLINE(  80)				this->events->remove(trash1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(EventTimeline_obj,update,(void))


::hx::ObjectPtr< EventTimeline_obj > EventTimeline_obj::__new() {
	::hx::ObjectPtr< EventTimeline_obj > __this = new EventTimeline_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< EventTimeline_obj > EventTimeline_obj::__alloc(::hx::Ctx *_hx_ctx) {
	EventTimeline_obj *__this = (EventTimeline_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(EventTimeline_obj), true, "modchart.EventTimeline"));
	*(void **)__this = EventTimeline_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

EventTimeline_obj::EventTimeline_obj()
{
}

void EventTimeline_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(EventTimeline);
	HX_MARK_MEMBER_NAME(modEvents,"modEvents");
	HX_MARK_MEMBER_NAME(events,"events");
	HX_MARK_END_CLASS();
}

void EventTimeline_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(modEvents,"modEvents");
	HX_VISIT_MEMBER_NAME(events,"events");
}

::hx::Val EventTimeline_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"events") ) { return ::hx::Val( events ); }
		if (HX_FIELD_EQ(inName,"addMod") ) { return ::hx::Val( addMod_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addEvent") ) { return ::hx::Val( addEvent_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"modEvents") ) { return ::hx::Val( modEvents ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val EventTimeline_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"events") ) { events=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"modEvents") ) { modEvents=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void EventTimeline_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("modEvents",7b,57,0a,a7));
	outFields->push(HX_("events",19,4f,6a,96));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo EventTimeline_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(EventTimeline_obj,modEvents),HX_("modEvents",7b,57,0a,a7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(EventTimeline_obj,events),HX_("events",19,4f,6a,96)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *EventTimeline_obj_sStaticStorageInfo = 0;
#endif

static ::String EventTimeline_obj_sMemberFields[] = {
	HX_("modEvents",7b,57,0a,a7),
	HX_("events",19,4f,6a,96),
	HX_("addMod",21,27,04,9f),
	HX_("addEvent",39,ee,21,ef),
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class EventTimeline_obj::__mClass;

void EventTimeline_obj::__register()
{
	EventTimeline_obj _hx_dummy;
	EventTimeline_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.EventTimeline",89,77,cc,d8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(EventTimeline_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< EventTimeline_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = EventTimeline_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = EventTimeline_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
