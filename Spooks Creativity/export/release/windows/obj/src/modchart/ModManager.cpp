// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StrumNote
#include <StrumNote.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_BalancedTree
#include <haxe/ds/BalancedTree.h>
#endif
#ifndef INCLUDED_haxe_ds_EnumValueMap
#include <haxe/ds/EnumValueMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_EventTimeline
#include <modchart/EventTimeline.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_ModifierType
#include <modchart/ModifierType.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_SubModifier
#include <modchart/SubModifier.h>
#endif
#ifndef INCLUDED_modchart_events_BaseEvent
#include <modchart/events/BaseEvent.h>
#endif
#ifndef INCLUDED_modchart_events_CallbackEvent
#include <modchart/events/CallbackEvent.h>
#endif
#ifndef INCLUDED_modchart_events_EaseEvent
#include <modchart/events/EaseEvent.h>
#endif
#ifndef INCLUDED_modchart_events_ModEvent
#include <modchart/events/ModEvent.h>
#endif
#ifndef INCLUDED_modchart_events_SetEvent
#include <modchart/events/SetEvent.h>
#endif
#ifndef INCLUDED_modchart_events_StepCallbackEvent
#include <modchart/events/StepCallbackEvent.h>
#endif
#ifndef INCLUDED_modchart_modifiers_AccelModifier
#include <modchart/modifiers/AccelModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_AlphaModifier
#include <modchart/modifiers/AlphaModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_BeatModifier
#include <modchart/modifiers/BeatModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ConfusionModifier
#include <modchart/modifiers/ConfusionModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_DrunkModifier
#include <modchart/modifiers/DrunkModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_FlipModifier
#include <modchart/modifiers/FlipModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_InfinitePathModifier
#include <modchart/modifiers/InfinitePathModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_InvertModifier
#include <modchart/modifiers/InvertModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_LocalRotateModifier
#include <modchart/modifiers/LocalRotateModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_OpponentModifier
#include <modchart/modifiers/OpponentModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_PathModifier
#include <modchart/modifiers/PathModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_PerspectiveModifier
#include <modchart/modifiers/PerspectiveModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ReceptorScrollModifier
#include <modchart/modifiers/ReceptorScrollModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ReverseModifier
#include <modchart/modifiers/ReverseModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_RotateModifier
#include <modchart/modifiers/RotateModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ScaleModifier
#include <modchart/modifiers/ScaleModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_TransformModifier
#include <modchart/modifiers/TransformModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_WiggleModifier
#include <modchart/modifiers/WiggleModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_XModifier
#include <modchart/modifiers/XModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_15_new,"modchart.ModManager","new",0xda295baf,"modchart.ModManager.new","modchart/ModManager.hx",15,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_18_registerDefaultModifiers,"modchart.ModManager","registerDefaultModifiers",0xb0b6b90f,"modchart.ModManager.registerDefaultModifiers","modchart/ModManager.hx",18,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_71_quickRegister,"modchart.ModManager","quickRegister",0xc2a7827f,"modchart.ModManager.quickRegister","modchart/ModManager.hx",71,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_94_registerMod,"modchart.ModManager","registerMod",0x7b2efa6e,"modchart.ModManager.registerMod","modchart/ModManager.hx",94,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_73_registerMod,"modchart.ModManager","registerMod",0x7b2efa6e,"modchart.ModManager.registerMod","modchart/ModManager.hx",73,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_99_get,"modchart.ModManager","get",0xda240be5,"modchart.ModManager.get","modchart/ModManager.hx",99,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_102_getPercent,"modchart.ModManager","getPercent",0x0d8f3d60,"modchart.ModManager.getPercent","modchart/ModManager.hx",102,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_105_getValue,"modchart.ModManager","getValue",0x24f3a54c,"modchart.ModManager.getValue","modchart/ModManager.hx",105,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_108_setPercent,"modchart.ModManager","setPercent",0x110cdbd4,"modchart.ModManager.setPercent","modchart/ModManager.hx",108,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_111_setValue,"modchart.ModManager","setValue",0xd350fec0,"modchart.ModManager.setValue","modchart/ModManager.hx",111,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_177_setValue,"modchart.ModManager","setValue",0xd350fec0,"modchart.ModManager.setValue","modchart/ModManager.hx",177,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_163_setValue,"modchart.ModManager","setValue",0xd350fec0,"modchart.ModManager.setValue","modchart/ModManager.hx",163,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_168_setValue,"modchart.ModManager","setValue",0xd350fec0,"modchart.ModManager.setValue","modchart/ModManager.hx",168,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_187_update,"modchart.ModManager","update",0xd530b61a,"modchart.ModManager.update","modchart/ModManager.hx",187,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_196_updateTimeline,"modchart.ModManager","updateTimeline",0x69488abb,"modchart.ModManager.updateTimeline","modchart/ModManager.hx",196,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_199_getBaseX,"modchart.ModManager","getBaseX",0xa0f54d02,"modchart.ModManager.getBaseX","modchart/ModManager.hx",199,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_214_updateObject,"modchart.ModManager","updateObject",0x9e9f3879,"modchart.ModManager.updateObject","modchart/ModManager.hx",214,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_242_getVisPos,"modchart.ModManager","getVisPos",0xcff61559,"modchart.ModManager.getVisPos","modchart/ModManager.hx",242,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_246_getPos,"modchart.ModManager","getPos",0xf14fc6af,"modchart.ModManager.getPos","modchart/ModManager.hx",246,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_267_queueEaseP,"modchart.ModManager","queueEaseP",0x7de405e2,"modchart.ModManager.queueEaseP","modchart/ModManager.hx",267,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_270_queueSetP,"modchart.ModManager","queueSetP",0x3328592e,"modchart.ModManager.queueSetP","modchart/ModManager.hx",270,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_273_ease,"modchart.ModManager","ease",0x0410e5bf,"modchart.ModManager.ease","modchart/ModManager.hx",273,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_276_set,"modchart.ModManager","set",0xda2d26f1,"modchart.ModManager.set","modchart/ModManager.hx",276,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_281_queueEase,"modchart.ModManager","queueEase",0x29e452ae,"modchart.ModManager.queueEase","modchart/ModManager.hx",281,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_302_queueSet,"modchart.ModManager","queueSet",0xd6e6ece2,"modchart.ModManager.queueSet","modchart/ModManager.hx",302,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_314_queueFunc,"modchart.ModManager","queueFunc",0x2a9cb204,"modchart.ModManager.queueFunc","modchart/ModManager.hx",314,0x2af94200)
HX_LOCAL_STACK_FRAME(_hx_pos_8ed5a7c9feec56a9_318_queueFuncOnce,"modchart.ModManager","queueFuncOnce",0x7e03ada5,"modchart.ModManager.queueFuncOnce","modchart/ModManager.hx",318,0x2af94200)
namespace modchart{

void ModManager_obj::__construct( ::PlayState state){
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_15_new)
HXLINE(  68)		this->activeMods = ::Array_obj< ::Dynamic>::__new(2)->init(0,::Array_obj< ::String >::__new(0))->init(1,::Array_obj< ::String >::__new(0));
HXLINE(  66)		this->modArray = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  64)		this->_hx_register =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  59)		 ::haxe::ds::EnumValueMap _g =  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX );
HXDLIN(  59)		_g->set(::modchart::ModifierType_obj::NOTE_MOD_dyn(), ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
HXDLIN(  59)		_g->set(::modchart::ModifierType_obj::MISC_MOD_dyn(), ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
HXDLIN(  59)		this->registerByType = _g;
HXLINE(  56)		this->miscmodRegister =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  55)		this->notemodRegister =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  53)		this->timeline =  ::modchart::EventTimeline_obj::__alloc( HX_CTX );
HXLINE(  52)		this->receptors = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  16)		this->modchartEnable = false;
HXLINE( 182)		this->state = state;
            	}

Dynamic ModManager_obj::__CreateEmpty() { return new ModManager_obj; }

void *ModManager_obj::_hx_vtable = 0;

Dynamic ModManager_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ModManager_obj > _hx_result = new ModManager_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool ModManager_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0388d33b;
}

void ModManager_obj::registerDefaultModifiers(){
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_18_registerDefaultModifiers)
HXLINE(  19)		::cpp::VirtualArray quickRegs = ::cpp::VirtualArray_obj::__new(16)->init(0,::hx::ClassOf< ::modchart::modifiers::FlipModifier >())->init(1,::hx::ClassOf< ::modchart::modifiers::ReverseModifier >())->init(2,::hx::ClassOf< ::modchart::modifiers::InvertModifier >())->init(3,::hx::ClassOf< ::modchart::modifiers::DrunkModifier >())->init(4,::hx::ClassOf< ::modchart::modifiers::BeatModifier >())->init(5,::hx::ClassOf< ::modchart::modifiers::AlphaModifier >())->init(6,::hx::ClassOf< ::modchart::modifiers::ReceptorScrollModifier >())->init(7,::hx::ClassOf< ::modchart::modifiers::ScaleModifier >())->init(8,::hx::ClassOf< ::modchart::modifiers::ConfusionModifier >())->init(9,::hx::ClassOf< ::modchart::modifiers::OpponentModifier >())->init(10,::hx::ClassOf< ::modchart::modifiers::TransformModifier >())->init(11,::hx::ClassOf< ::modchart::modifiers::InfinitePathModifier >())->init(12,::hx::ClassOf< ::modchart::modifiers::PerspectiveModifier >())->init(13,::hx::ClassOf< ::modchart::modifiers::AccelModifier >())->init(14,::hx::ClassOf< ::modchart::modifiers::WiggleModifier >())->init(15,::hx::ClassOf< ::modchart::modifiers::XModifier >());
HXLINE(  37)		{
HXLINE(  37)			int _g = 0;
HXDLIN(  37)			while((_g < quickRegs->get_length())){
HXLINE(  37)				 ::Dynamic mod = quickRegs->__get(_g);
HXDLIN(  37)				_g = (_g + 1);
HXLINE(  38)				{
HXLINE(  38)					 ::modchart::Modifier mod1 = ( ( ::modchart::Modifier)(::Type_obj::createInstance(mod,::cpp::VirtualArray_obj::__new(1)->init(0,::hx::ObjectPtr<OBJ_>(this)))) );
HXDLIN(  38)					this->registerMod(mod1->getName(),mod1,null());
            				}
            			}
            		}
HXLINE(  40)		{
HXLINE(  40)			 ::modchart::Modifier mod2 =  ::modchart::modifiers::RotateModifier_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXDLIN(  40)			this->registerMod(mod2->getName(),mod2,null());
            		}
HXLINE(  41)		{
HXLINE(  41)			 ::modchart::Modifier mod3 =  ::modchart::modifiers::RotateModifier_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),HX_("center",d5,25,db,05), ::math::Vector3_obj::__alloc( HX_CTX ,((( (Float)(::flixel::FlxG_obj::width) ) * ((Float)0.5)) - (::Note_obj::swagWidth / ( (Float)(2) ))),((( (Float)(::flixel::FlxG_obj::height) ) * ((Float)0.5)) - (::Note_obj::swagWidth / ( (Float)(2) ))),null()),null());
HXDLIN(  41)			this->registerMod(mod3->getName(),mod3,null());
            		}
HXLINE(  42)		{
HXLINE(  42)			 ::modchart::Modifier mod4 =  ::modchart::modifiers::LocalRotateModifier_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),HX_("local",6b,c9,f0,78),null());
HXDLIN(  42)			this->registerMod(mod4->getName(),mod4,null());
            		}
HXLINE(  43)		{
HXLINE(  43)			 ::modchart::Modifier mod5 =  ::modchart::SubModifier_obj::__alloc( HX_CTX ,HX_("noteSpawnTime",96,09,3b,0b),::hx::ObjectPtr<OBJ_>(this),null());
HXDLIN(  43)			this->registerMod(mod5->getName(),mod5,null());
            		}
HXLINE(  44)		this->setValue(HX_("noteSpawnTime",96,09,3b,0b),( (Float)(2000) ),null());
HXLINE(  45)		this->setValue(HX_("xmod",4a,b1,a4,4f),( (Float)(1) ),null());
HXLINE(  46)		{
HXLINE(  47)			this->setValue((HX_("xmod",4a,b1,a4,4f) + 0),( (Float)(1) ),null());
HXDLIN(  47)			this->setValue((HX_("xmod",4a,b1,a4,4f) + 1),( (Float)(1) ),null());
HXDLIN(  47)			this->setValue((HX_("xmod",4a,b1,a4,4f) + 2),( (Float)(1) ),null());
HXDLIN(  47)			this->setValue((HX_("xmod",4a,b1,a4,4f) + 3),( (Float)(1) ),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ModManager_obj,registerDefaultModifiers,(void))

void ModManager_obj::quickRegister( ::modchart::Modifier mod){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_71_quickRegister)
HXDLIN(  71)		this->registerMod(mod->getName(),mod,null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(ModManager_obj,quickRegister,(void))

void ModManager_obj::registerMod(::String modName, ::modchart::Modifier mod, ::Dynamic __o_registerSubmods){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		int _hx_run( ::modchart::Modifier a, ::modchart::Modifier b){
            			HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_94_registerMod)
HXLINE(  94)			int _hx_tmp = a->getOrder();
HXDLIN(  94)			return ::Std_obj::_hx_int(( (Float)((_hx_tmp - b->getOrder())) ));
            		}
            		HX_END_LOCAL_FUNC2(return)

            		 ::Dynamic registerSubmods = __o_registerSubmods;
            		if (::hx::IsNull(__o_registerSubmods)) registerSubmods = true;
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_73_registerMod)
HXLINE(  74)		this->_hx_register->set(modName,mod);
HXLINE(  76)		switch((int)(mod->getModType()->_hx_getIndex())){
            			case (int)0: {
HXLINE(  78)				this->notemodRegister->set(modName,mod);
            			}
            			break;
            			case (int)1: {
HXLINE(  80)				this->miscmodRegister->set(modName,mod);
            			}
            			break;
            		}
HXLINE(  82)		this->timeline->addMod(modName);
HXLINE(  83)		this->modArray->push(mod);
HXLINE(  85)		if (( (bool)(registerSubmods) )) {
HXLINE(  86)			 ::Dynamic name = mod->submods->keys();
HXDLIN(  86)			while(( (bool)(name->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  86)				::String name1 = ( (::String)(name->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  88)				 ::modchart::Modifier submod = ( ( ::modchart::Modifier)(mod->submods->get(name1)) );
HXLINE(  89)				this->registerMod(submod->getName(),submod,null());
            			}
            		}
HXLINE(  93)		this->setValue(modName,( (Float)(0) ),null());
HXLINE(  94)		this->modArray->sort( ::Dynamic(new _hx_Closure_0()));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModManager_obj,registerMod,(void))

 ::modchart::Modifier ModManager_obj::get(::String modName){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_99_get)
HXDLIN(  99)		return ( ( ::modchart::Modifier)(this->_hx_register->get(modName)) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(ModManager_obj,get,return )

Float ModManager_obj::getPercent(::String modName,int player){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_102_getPercent)
HXDLIN( 102)		return ( ( ::modchart::Modifier)(this->_hx_register->get(modName)) )->getPercent(player);
            	}


HX_DEFINE_DYNAMIC_FUNC2(ModManager_obj,getPercent,return )

Float ModManager_obj::getValue(::String modName,int player){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_105_getValue)
HXDLIN( 105)		return ( ( ::modchart::Modifier)(this->_hx_register->get(modName)) )->getValue(player);
            	}


HX_DEFINE_DYNAMIC_FUNC2(ModManager_obj,getValue,return )

void ModManager_obj::setPercent(::String modName,Float val,::hx::Null< int >  __o_player){
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_108_setPercent)
HXDLIN( 108)		this->setValue(modName,(val * ((Float)0.01)),player);
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModManager_obj,setPercent,(void))

void ModManager_obj::setValue(::String modName,Float val,::hx::Null< int >  __o_player){
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_111_setValue)
HXDLIN( 111)		 ::modchart::ModManager _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 112)		if ((player == -1)) {
HXLINE( 115)			this->setValue(modName,val,0);
HXDLIN( 115)			this->setValue(modName,val,1);
            		}
            		else {
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::modchart::ModManager,_gthis) HXARGC(2)
            			int _hx_run(::String a,::String b){
            				HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_177_setValue)
HXLINE( 177)				int _hx_tmp = ( ( ::modchart::Modifier)(_gthis->_hx_register->get(a)) )->getOrder();
HXDLIN( 177)				return ::Std_obj::_hx_int(( (Float)((_hx_tmp - ( ( ::modchart::Modifier)(_gthis->_hx_register->get(b)) )->getOrder())) ));
            			}
            			HX_END_LOCAL_FUNC2(return)

HXLINE( 119)			 ::modchart::Modifier daMod = ( ( ::modchart::Modifier)(this->_hx_register->get(modName)) );
HXLINE( 120)			if (::hx::IsNull( daMod )) {
HXLINE( 122)				::haxe::Log_obj::trace(((HX_("cannot set ",7b,88,fa,0b) + modName) + HX_(" because it is null lol",eb,dc,d8,07)),::hx::SourceInfo(HX_("source/modchart/ModManager.hx",f4,27,64,da),122,HX_("modchart.ModManager",3d,58,f0,20),HX_("setValue",6f,e8,ec,3f)));
HXLINE( 123)				return;
            			}
HXLINE( 125)			 ::modchart::Modifier mod;
HXDLIN( 125)			if (::hx::IsNull( daMod->parent )) {
HXLINE( 125)				mod = daMod;
            			}
            			else {
HXLINE( 125)				mod = daMod->parent;
            			}
HXLINE( 126)			::String name = mod->getName();
HXLINE( 138)			if (::hx::IsNull( this->activeMods->__get(player).StaticCast< ::Array< ::String > >() )) {
HXLINE( 139)				this->activeMods[player] = ::Array_obj< ::String >::__new(0);
            			}
HXLINE( 141)			( ( ::modchart::Modifier)(this->_hx_register->get(modName)) )->setValue(val,player);
HXLINE( 143)			bool _hx_tmp;
HXDLIN( 143)			if (!(this->activeMods->__get(player).StaticCast< ::Array< ::String > >()->contains(name))) {
HXLINE( 143)				_hx_tmp = mod->shouldExecute(player,val);
            			}
            			else {
HXLINE( 143)				_hx_tmp = false;
            			}
HXDLIN( 143)			if (_hx_tmp) {
HXLINE( 144)				if ((daMod->getName() != name)) {
HXLINE( 145)					::Array< ::String > _hx_tmp1 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 145)					_hx_tmp1->push(daMod->getName());
            				}
HXLINE( 146)				this->activeMods->__get(player).StaticCast< ::Array< ::String > >()->push(name);
            			}
            			else {
HXLINE( 147)				if (!(mod->shouldExecute(player,val))) {
HXLINE( 151)					 ::modchart::Modifier modParent = daMod->parent;
HXLINE( 152)					if (::hx::IsNull( modParent )) {
HXLINE( 153)						::Dynamic map = daMod->submods;
HXDLIN( 153)						::Dynamic _g_map = map;
HXDLIN( 153)						 ::Dynamic _g_keys = ::haxe::IMap_obj::keys(map);
HXDLIN( 153)						while(( (bool)(_g_keys->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 153)							::String key = ( (::String)(_g_keys->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 153)							 ::modchart::Modifier _g_value = ( ( ::modchart::Modifier)(::haxe::IMap_obj::get(_g_map,key)) );
HXDLIN( 153)							::String _g_key = key;
HXDLIN( 153)							::String name1 = _g_key;
HXDLIN( 153)							 ::modchart::Modifier mod1 = _g_value;
HXLINE( 155)							modParent = daMod;
HXLINE( 156)							goto _hx_goto_11;
            						}
            						_hx_goto_11:;
            					}
HXLINE( 159)					if (::hx::IsInstanceNotEq( daMod,modParent )) {
HXLINE( 160)						::Array< ::String > _hx_tmp2 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 160)						_hx_tmp2->remove(daMod->getName());
            					}
HXLINE( 161)					if (::hx::IsNotNull( modParent )) {
HXLINE( 162)						if (modParent->shouldExecute(player,modParent->getValue(player))) {
            							HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::modchart::ModManager,_gthis) HXARGC(2)
            							int _hx_run(::String a,::String b){
            								HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_163_setValue)
HXLINE( 163)								int _hx_tmp = ( ( ::modchart::Modifier)(_gthis->_hx_register->get(a)) )->getOrder();
HXDLIN( 163)								return ::Std_obj::_hx_int(( (Float)((_hx_tmp - ( ( ::modchart::Modifier)(_gthis->_hx_register->get(b)) )->getOrder())) ));
            							}
            							HX_END_LOCAL_FUNC2(return)

HXLINE( 163)							this->activeMods->__get(player).StaticCast< ::Array< ::String > >()->sort( ::Dynamic(new _hx_Closure_0(_gthis)));
HXLINE( 164)							return;
            						}
HXLINE( 166)						{
HXLINE( 166)							::Dynamic map1 = modParent->submods;
HXDLIN( 166)							::Dynamic _g_map1 = map1;
HXDLIN( 166)							 ::Dynamic _g_keys1 = ::haxe::IMap_obj::keys(map1);
HXDLIN( 166)							while(( (bool)(_g_keys1->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 166)								::String key1 = ( (::String)(_g_keys1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 166)								 ::modchart::Modifier _g_value1 = ( ( ::modchart::Modifier)(::haxe::IMap_obj::get(_g_map1,key1)) );
HXDLIN( 166)								::String _g_key1 = key1;
HXDLIN( 166)								::String subname = _g_key1;
HXDLIN( 166)								 ::modchart::Modifier submod = _g_value1;
HXLINE( 167)								if (submod->shouldExecute(player,submod->getValue(player))) {
            									HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::modchart::ModManager,_gthis) HXARGC(2)
            									int _hx_run(::String a,::String b){
            										HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_168_setValue)
HXLINE( 168)										int _hx_tmp = ( ( ::modchart::Modifier)(_gthis->_hx_register->get(a)) )->getOrder();
HXDLIN( 168)										return ::Std_obj::_hx_int(( (Float)((_hx_tmp - ( ( ::modchart::Modifier)(_gthis->_hx_register->get(b)) )->getOrder())) ));
            									}
            									HX_END_LOCAL_FUNC2(return)

HXLINE( 168)									this->activeMods->__get(player).StaticCast< ::Array< ::String > >()->sort( ::Dynamic(new _hx_Closure_1(_gthis)));
HXLINE( 169)									return;
            								}
            							}
            						}
HXLINE( 172)						::Array< ::String > _hx_tmp3 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 172)						_hx_tmp3->remove(modParent->getName());
            					}
            					else {
HXLINE( 174)						::Array< ::String > _hx_tmp4 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 174)						_hx_tmp4->remove(daMod->getName());
            					}
            				}
            			}
HXLINE( 177)			this->activeMods->__get(player).StaticCast< ::Array< ::String > >()->sort( ::Dynamic(new _hx_Closure_2(_gthis)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModManager_obj,setValue,(void))

void ModManager_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_187_update)
HXDLIN( 187)		if (this->modchartEnable) {
HXLINE( 188)			int _g = 0;
HXDLIN( 188)			::Array< ::Dynamic> _g1 = this->modArray;
HXDLIN( 188)			while((_g < _g1->length)){
HXLINE( 188)				 ::modchart::Modifier mod = _g1->__get(_g).StaticCast<  ::modchart::Modifier >();
HXDLIN( 188)				_g = (_g + 1);
HXLINE( 190)				bool _hx_tmp;
HXDLIN( 190)				if (mod->active) {
HXLINE( 190)					_hx_tmp = mod->doesUpdate();
            				}
            				else {
HXLINE( 190)					_hx_tmp = false;
            				}
HXDLIN( 190)				if (_hx_tmp) {
HXLINE( 191)					mod->update(elapsed);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ModManager_obj,update,(void))

void ModManager_obj::updateTimeline(Float curStep){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_196_updateTimeline)
HXDLIN( 196)		this->timeline->update(curStep);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ModManager_obj,updateTimeline,(void))

Float ModManager_obj::getBaseX(int direction,int player){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_199_getBaseX)
HXLINE( 200)		Float x = ((((( (Float)(::flixel::FlxG_obj::width) ) * ((Float)0.5)) - ::Note_obj::swagWidth) - ( (Float)(54) )) + (::Note_obj::swagWidth * ( (Float)(direction) )));
HXLINE( 201)		switch((int)(player)){
            			case (int)0: {
HXLINE( 204)				x = (x + (((( (Float)(::flixel::FlxG_obj::width) ) * ((Float)0.5)) - (::Note_obj::swagWidth * ( (Float)(2) ))) - ( (Float)(100) )));
            			}
            			break;
            			case (int)1: {
HXLINE( 206)				x = (x - (((( (Float)(::flixel::FlxG_obj::width) ) * ((Float)0.5)) - (::Note_obj::swagWidth * ( (Float)(2) ))) - ( (Float)(100) )));
            			}
            			break;
            		}
HXLINE( 209)		x = (x - ( (Float)(56) ));
HXLINE( 211)		return x;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ModManager_obj,getBaseX,return )

void ModManager_obj::updateObject(Float beat, ::flixel::FlxSprite obj, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_214_updateObject)
HXLINE( 215)		{
HXLINE( 215)			int _g = 0;
HXDLIN( 215)			::Array< ::String > _g1 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 215)			while((_g < _g1->length)){
HXLINE( 215)				::String name = _g1->__get(_g);
HXDLIN( 215)				_g = (_g + 1);
HXLINE( 217)				 ::modchart::Modifier mod = ( ( ::modchart::Modifier)(this->notemodRegister->get(name)) );
HXLINE( 218)				if (::hx::IsNull( mod )) {
HXLINE( 218)					continue;
            				}
HXLINE( 219)				if (!(obj->active)) {
HXLINE( 220)					continue;
            				}
HXLINE( 221)				if (::Std_obj::isOfType(obj,::hx::ClassOf< ::Note >())) {
HXLINE( 222)					 ::Note o = ( ( ::Note)(obj) );
HXLINE( 223)					mod->updateNote(beat,o,pos,player);
            				}
            				else {
HXLINE( 225)					if (::Std_obj::isOfType(obj,::hx::ClassOf< ::StrumNote >())) {
HXLINE( 226)						 ::StrumNote o1 = ( ( ::StrumNote)(obj) );
HXLINE( 227)						mod->updateReceptor(beat,o1,pos,player);
            					}
            				}
            			}
            		}
HXLINE( 230)		if (::Std_obj::isOfType(obj,::hx::ClassOf< ::Note >())) {
HXLINE( 230)			obj->updateHitbox();
            		}
HXLINE( 232)		{
HXLINE( 232)			 ::flixel::math::FlxBasePoint this1 = obj->origin;
HXDLIN( 232)			Float y = (( (Float)(obj->frameHeight) ) * ((Float)0.5));
HXDLIN( 232)			this1->set_x((( (Float)(obj->frameWidth) ) * ((Float)0.5)));
HXDLIN( 232)			this1->set_y(y);
            		}
HXLINE( 233)		obj->centerOffsets(null());
HXLINE( 234)		if (::Std_obj::isOfType(obj,::hx::ClassOf< ::Note >())) {
HXLINE( 235)			 ::Note cum = ( ( ::Note)(obj) );
HXLINE( 236)			cum->offset->set_x((cum->offset->x + cum->typeOffsetX));
HXLINE( 237)			cum->offset->set_y((cum->offset->y + cum->typeOffsetY));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(ModManager_obj,updateObject,(void))

Float ModManager_obj::getVisPos(::hx::Null< Float >  __o_songPos,::hx::Null< Float >  __o_strumTime,::hx::Null< Float >  __o_songSpeed){
            		Float songPos = __o_songPos.Default(0);
            		Float strumTime = __o_strumTime.Default(0);
            		Float songSpeed = __o_songSpeed.Default(1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_242_getVisPos)
HXDLIN( 242)		return -(((((Float)0.45) * (songPos - strumTime)) * songSpeed));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModManager_obj,getVisPos,return )

 ::math::Vector3 ModManager_obj::getPos(Float time,Float diff,Float tDiff,Float beat,int data,int player, ::flixel::FlxSprite obj,::Array< ::String > exclusions, ::math::Vector3 pos){
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_246_getPos)
HXLINE( 247)		if (::hx::IsNull( exclusions )) {
HXLINE( 247)			exclusions = ::Array_obj< ::String >::__new(0);
            		}
HXLINE( 248)		if (::hx::IsNull( pos )) {
HXLINE( 249)			pos =  ::math::Vector3_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXLINE( 251)		if (!(obj->active)) {
HXLINE( 251)			return pos;
            		}
HXLINE( 253)		pos->x = this->getBaseX(data,player);
HXLINE( 254)		pos->y = (50 + diff);
HXLINE( 255)		pos->z = ( (Float)(0) );
HXLINE( 256)		{
HXLINE( 256)			int _g = 0;
HXDLIN( 256)			::Array< ::String > _g1 = this->activeMods->__get(player).StaticCast< ::Array< ::String > >();
HXDLIN( 256)			while((_g < _g1->length)){
HXLINE( 256)				::String name = _g1->__get(_g);
HXDLIN( 256)				_g = (_g + 1);
HXLINE( 257)				if (exclusions->contains(name)) {
HXLINE( 257)					continue;
            				}
HXLINE( 258)				 ::modchart::Modifier mod = ( ( ::modchart::Modifier)(this->notemodRegister->get(name)) );
HXLINE( 259)				if (::hx::IsNull( mod )) {
HXLINE( 259)					continue;
            				}
HXLINE( 260)				if (!(obj->active)) {
HXLINE( 260)					continue;
            				}
HXLINE( 261)				pos = mod->getPos(time,diff,tDiff,beat,pos,data,player,obj);
            			}
            		}
HXLINE( 263)		return pos;
            	}


HX_DEFINE_DYNAMIC_FUNC9(ModManager_obj,getPos,return )

void ModManager_obj::queueEaseP(Float step,Float endStep,::String modName,Float percent,::String __o_style,::hx::Null< int >  __o_player, ::Dynamic startVal){
            		::String style = __o_style;
            		if (::hx::IsNull(__o_style)) style = HX_("linear",e5,51,a0,ec);
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_267_queueEaseP)
HXDLIN( 267)		this->queueEase(step,endStep,modName,(percent * ((Float)0.01)),style,player,(( (Float)(startVal) ) * ((Float)0.01)));
            	}


HX_DEFINE_DYNAMIC_FUNC7(ModManager_obj,queueEaseP,(void))

void ModManager_obj::queueSetP(Float step,::String modName,Float percent,::hx::Null< int >  __o_player){
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_270_queueSetP)
HXDLIN( 270)		this->queueSet(step,modName,(percent * ((Float)0.01)),player);
            	}


HX_DEFINE_DYNAMIC_FUNC4(ModManager_obj,queueSetP,(void))

void ModManager_obj::ease(Float beat,Float beatDur,::String modName,Float target,::String __o_style,::hx::Null< int >  __o_player, ::Dynamic startVal){
            		::String style = __o_style;
            		if (::hx::IsNull(__o_style)) style = HX_("linear",e5,51,a0,ec);
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_273_ease)
HXDLIN( 273)		this->queueEase((beat * ( (Float)(4) )),((beat * ( (Float)(4) )) + (beatDur * ( (Float)(4) ))),modName,target,style,player,null());
            	}


HX_DEFINE_DYNAMIC_FUNC7(ModManager_obj,ease,(void))

void ModManager_obj::set(Float beat,::String modName,Float target,::hx::Null< int >  __o_player){
            		int player = __o_player.Default(-1);
            	HX_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_276_set)
HXDLIN( 276)		this->queueSet((beat * ( (Float)(4) )),modName,target,player);
            	}


HX_DEFINE_DYNAMIC_FUNC4(ModManager_obj,set,(void))

void ModManager_obj::queueEase(Float step,Float endStep,::String modName,Float target,::String __o_style,::hx::Null< int >  __o_player, ::Dynamic startVal){
            		::String style = __o_style;
            		if (::hx::IsNull(__o_style)) style = HX_("linear",e5,51,a0,ec);
            		int player = __o_player.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_281_queueEase)
HXDLIN( 281)		if ((player == -1)) {
HXLINE( 282)			this->queueEase(step,endStep,modName,target,style,0,null());
HXLINE( 283)			this->queueEase(step,endStep,modName,target,style,1,null());
            		}
            		else {
HXLINE( 285)			 ::Dynamic easeFunc = ::flixel::tweens::FlxEase_obj::linear_dyn();
HXLINE( 288)			{
HXLINE( 289)				 ::Dynamic newEase = ::Reflect_obj::getProperty(::hx::ClassOf< ::flixel::tweens::FlxEase >(),style);
HXLINE( 290)				if (::hx::IsNotNull( newEase )) {
HXLINE( 291)					easeFunc = newEase;
            				}
            			}
HXLINE( 295)			 ::modchart::EventTimeline _hx_tmp = this->timeline;
HXDLIN( 295)			_hx_tmp->addEvent( ::modchart::events::EaseEvent_obj::__alloc( HX_CTX ,step,endStep,modName,target,easeFunc,player,::hx::ObjectPtr<OBJ_>(this),null()));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(ModManager_obj,queueEase,(void))

void ModManager_obj::queueSet(Float step,::String modName,Float target,::hx::Null< int >  __o_player){
            		int player = __o_player.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_302_queueSet)
HXDLIN( 302)		if ((player == -1)) {
HXLINE( 304)			this->queueSet(step,modName,target,0);
HXLINE( 305)			this->queueSet(step,modName,target,1);
            		}
            		else {
HXLINE( 308)			 ::modchart::EventTimeline _hx_tmp = this->timeline;
HXDLIN( 308)			_hx_tmp->addEvent( ::modchart::events::SetEvent_obj::__alloc( HX_CTX ,step,modName,target,player,::hx::ObjectPtr<OBJ_>(this)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(ModManager_obj,queueSet,(void))

void ModManager_obj::queueFunc(Float step,Float endStep, ::Dynamic callback){
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_314_queueFunc)
HXDLIN( 314)		 ::modchart::EventTimeline _hx_tmp = this->timeline;
HXDLIN( 314)		_hx_tmp->addEvent( ::modchart::events::StepCallbackEvent_obj::__alloc( HX_CTX ,step,endStep,callback,::hx::ObjectPtr<OBJ_>(this)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ModManager_obj,queueFunc,(void))

void ModManager_obj::queueFuncOnce(Float step, ::Dynamic callback){
            	HX_GC_STACKFRAME(&_hx_pos_8ed5a7c9feec56a9_318_queueFuncOnce)
HXDLIN( 318)		 ::modchart::EventTimeline _hx_tmp = this->timeline;
HXDLIN( 318)		_hx_tmp->addEvent( ::modchart::events::CallbackEvent_obj::__alloc( HX_CTX ,step,callback,::hx::ObjectPtr<OBJ_>(this)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(ModManager_obj,queueFuncOnce,(void))


::hx::ObjectPtr< ModManager_obj > ModManager_obj::__new( ::PlayState state) {
	::hx::ObjectPtr< ModManager_obj > __this = new ModManager_obj();
	__this->__construct(state);
	return __this;
}

::hx::ObjectPtr< ModManager_obj > ModManager_obj::__alloc(::hx::Ctx *_hx_ctx, ::PlayState state) {
	ModManager_obj *__this = (ModManager_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ModManager_obj), true, "modchart.ModManager"));
	*(void **)__this = ModManager_obj::_hx_vtable;
	__this->__construct(state);
	return __this;
}

ModManager_obj::ModManager_obj()
{
}

void ModManager_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ModManager);
	HX_MARK_MEMBER_NAME(modchartEnable,"modchartEnable");
	HX_MARK_MEMBER_NAME(state,"state");
	HX_MARK_MEMBER_NAME(receptors,"receptors");
	HX_MARK_MEMBER_NAME(timeline,"timeline");
	HX_MARK_MEMBER_NAME(notemodRegister,"notemodRegister");
	HX_MARK_MEMBER_NAME(miscmodRegister,"miscmodRegister");
	HX_MARK_MEMBER_NAME(registerByType,"registerByType");
	HX_MARK_MEMBER_NAME(_hx_register,"register");
	HX_MARK_MEMBER_NAME(modArray,"modArray");
	HX_MARK_MEMBER_NAME(activeMods,"activeMods");
	HX_MARK_END_CLASS();
}

void ModManager_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(modchartEnable,"modchartEnable");
	HX_VISIT_MEMBER_NAME(state,"state");
	HX_VISIT_MEMBER_NAME(receptors,"receptors");
	HX_VISIT_MEMBER_NAME(timeline,"timeline");
	HX_VISIT_MEMBER_NAME(notemodRegister,"notemodRegister");
	HX_VISIT_MEMBER_NAME(miscmodRegister,"miscmodRegister");
	HX_VISIT_MEMBER_NAME(registerByType,"registerByType");
	HX_VISIT_MEMBER_NAME(_hx_register,"register");
	HX_VISIT_MEMBER_NAME(modArray,"modArray");
	HX_VISIT_MEMBER_NAME(activeMods,"activeMods");
}

::hx::Val ModManager_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { return ::hx::Val( get_dyn() ); }
		if (HX_FIELD_EQ(inName,"set") ) { return ::hx::Val( set_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"ease") ) { return ::hx::Val( ease_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { return ::hx::Val( state ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPos") ) { return ::hx::Val( getPos_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"timeline") ) { return ::hx::Val( timeline ); }
		if (HX_FIELD_EQ(inName,"register") ) { return ::hx::Val( _hx_register ); }
		if (HX_FIELD_EQ(inName,"modArray") ) { return ::hx::Val( modArray ); }
		if (HX_FIELD_EQ(inName,"getValue") ) { return ::hx::Val( getValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"setValue") ) { return ::hx::Val( setValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"getBaseX") ) { return ::hx::Val( getBaseX_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueSet") ) { return ::hx::Val( queueSet_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { return ::hx::Val( receptors ); }
		if (HX_FIELD_EQ(inName,"getVisPos") ) { return ::hx::Val( getVisPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueSetP") ) { return ::hx::Val( queueSetP_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueEase") ) { return ::hx::Val( queueEase_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueFunc") ) { return ::hx::Val( queueFunc_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"activeMods") ) { return ::hx::Val( activeMods ); }
		if (HX_FIELD_EQ(inName,"getPercent") ) { return ::hx::Val( getPercent_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPercent") ) { return ::hx::Val( setPercent_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueEaseP") ) { return ::hx::Val( queueEaseP_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"registerMod") ) { return ::hx::Val( registerMod_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"updateObject") ) { return ::hx::Val( updateObject_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"quickRegister") ) { return ::hx::Val( quickRegister_dyn() ); }
		if (HX_FIELD_EQ(inName,"queueFuncOnce") ) { return ::hx::Val( queueFuncOnce_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"modchartEnable") ) { return ::hx::Val( modchartEnable ); }
		if (HX_FIELD_EQ(inName,"registerByType") ) { return ::hx::Val( registerByType ); }
		if (HX_FIELD_EQ(inName,"updateTimeline") ) { return ::hx::Val( updateTimeline_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"notemodRegister") ) { return ::hx::Val( notemodRegister ); }
		if (HX_FIELD_EQ(inName,"miscmodRegister") ) { return ::hx::Val( miscmodRegister ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"registerDefaultModifiers") ) { return ::hx::Val( registerDefaultModifiers_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ModManager_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { state=inValue.Cast<  ::PlayState >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"timeline") ) { timeline=inValue.Cast<  ::modchart::EventTimeline >(); return inValue; }
		if (HX_FIELD_EQ(inName,"register") ) { _hx_register=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"modArray") ) { modArray=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { receptors=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"activeMods") ) { activeMods=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"modchartEnable") ) { modchartEnable=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"registerByType") ) { registerByType=inValue.Cast<  ::haxe::ds::EnumValueMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"notemodRegister") ) { notemodRegister=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"miscmodRegister") ) { miscmodRegister=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ModManager_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("modchartEnable",7f,76,13,30));
	outFields->push(HX_("state",11,76,0b,84));
	outFields->push(HX_("receptors",37,7d,22,c1));
	outFields->push(HX_("timeline",81,6e,3b,fd));
	outFields->push(HX_("notemodRegister",93,f4,a0,48));
	outFields->push(HX_("miscmodRegister",d9,07,56,5a));
	outFields->push(HX_("registerByType",f4,32,99,d8));
	outFields->push(HX_("register",63,a6,9f,d0));
	outFields->push(HX_("modArray",77,07,b6,16));
	outFields->push(HX_("activeMods",57,9c,8b,f1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ModManager_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(ModManager_obj,modchartEnable),HX_("modchartEnable",7f,76,13,30)},
	{::hx::fsObject /*  ::PlayState */ ,(int)offsetof(ModManager_obj,state),HX_("state",11,76,0b,84)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ModManager_obj,receptors),HX_("receptors",37,7d,22,c1)},
	{::hx::fsObject /*  ::modchart::EventTimeline */ ,(int)offsetof(ModManager_obj,timeline),HX_("timeline",81,6e,3b,fd)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(ModManager_obj,notemodRegister),HX_("notemodRegister",93,f4,a0,48)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(ModManager_obj,miscmodRegister),HX_("miscmodRegister",d9,07,56,5a)},
	{::hx::fsObject /*  ::haxe::ds::EnumValueMap */ ,(int)offsetof(ModManager_obj,registerByType),HX_("registerByType",f4,32,99,d8)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(ModManager_obj,_hx_register),HX_("register",63,a6,9f,d0)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ModManager_obj,modArray),HX_("modArray",77,07,b6,16)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ModManager_obj,activeMods),HX_("activeMods",57,9c,8b,f1)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ModManager_obj_sStaticStorageInfo = 0;
#endif

static ::String ModManager_obj_sMemberFields[] = {
	HX_("modchartEnable",7f,76,13,30),
	HX_("registerDefaultModifiers",be,30,21,b2),
	HX_("state",11,76,0b,84),
	HX_("receptors",37,7d,22,c1),
	HX_("timeline",81,6e,3b,fd),
	HX_("notemodRegister",93,f4,a0,48),
	HX_("miscmodRegister",d9,07,56,5a),
	HX_("registerByType",f4,32,99,d8),
	HX_("register",63,a6,9f,d0),
	HX_("modArray",77,07,b6,16),
	HX_("activeMods",57,9c,8b,f1),
	HX_("quickRegister",70,1e,b3,e3),
	HX_("registerMod",1f,08,d7,17),
	HX_("get",96,80,4e,00),
	HX_("getPercent",cf,30,3c,c8),
	HX_("getValue",fb,8e,8f,91),
	HX_("setPercent",43,cf,b9,cb),
	HX_("setValue",6f,e8,ec,3f),
	HX_("update",09,86,05,87),
	HX_("updateTimeline",aa,61,65,32),
	HX_("getBaseX",b1,36,91,0d),
	HX_("updateObject",a8,25,03,15),
	HX_("getVisPos",ca,a4,c6,6b),
	HX_("getPos",9e,96,24,a3),
	HX_("queueEaseP",51,f9,90,38),
	HX_("queueSetP",9f,e8,f8,ce),
	HX_("ease",ee,8b,0c,43),
	HX_("set",a2,9b,57,00),
	HX_("queueEase",1f,e2,b4,c5),
	HX_("queueSet",91,d6,82,43),
	HX_("queueFunc",75,41,6d,c6),
	HX_("queueFuncOnce",96,49,0f,9f),
	::String(null()) };

::hx::Class ModManager_obj::__mClass;

void ModManager_obj::__register()
{
	ModManager_obj _hx_dummy;
	ModManager_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.ModManager",3d,58,f0,20);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ModManager_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ModManager_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ModManager_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ModManager_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
