// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_StrumNote
#include <StrumNote.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_PerspectiveModifier
#include <modchart/modifiers/PerspectiveModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_32fa8016a810fe3e_24_new,"modchart.modifiers.PerspectiveModifier","new",0xd3f1d801,"modchart.modifiers.PerspectiveModifier.new","modchart/modifiers/PerspectiveModifier.hx",24,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_25_getName,"modchart.modifiers.PerspectiveModifier","getName",0x97b30e22,"modchart.modifiers.PerspectiveModifier.getName","modchart/modifiers/PerspectiveModifier.hx",25,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_27_getOrder,"modchart.modifiers.PerspectiveModifier","getOrder",0xc395b0d7,"modchart.modifiers.PerspectiveModifier.getOrder","modchart/modifiers/PerspectiveModifier.hx",27,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_28_shouldExecute,"modchart.modifiers.PerspectiveModifier","shouldExecute",0xa28f8123,"modchart.modifiers.PerspectiveModifier.shouldExecute","modchart/modifiers/PerspectiveModifier.hx",28,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_36_FastTan,"modchart.modifiers.PerspectiveModifier","FastTan",0x27aeed26,"modchart.modifiers.PerspectiveModifier.FastTan","modchart/modifiers/PerspectiveModifier.hx",36,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_40_getVector,"modchart.modifiers.PerspectiveModifier","getVector",0xaf11305a,"modchart.modifiers.PerspectiveModifier.getVector","modchart/modifiers/PerspectiveModifier.hx",40,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_78_getPos,"modchart.modifiers.PerspectiveModifier","getPos",0x7130499d,"modchart.modifiers.PerspectiveModifier.getPos","modchart/modifiers/PerspectiveModifier.hx",78,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_82_updateReceptor,"modchart.modifiers.PerspectiveModifier","updateReceptor",0x674b84e4,"modchart.modifiers.PerspectiveModifier.updateReceptor","modchart/modifiers/PerspectiveModifier.hx",82,0xa8374f51)
HX_LOCAL_STACK_FRAME(_hx_pos_32fa8016a810fe3e_87_updateNote,"modchart.modifiers.PerspectiveModifier","updateNote",0x57b9a11a,"modchart.modifiers.PerspectiveModifier.updateNote","modchart/modifiers/PerspectiveModifier.hx",87,0xa8374f51)
namespace modchart{
namespace modifiers{

void PerspectiveModifier_obj::__construct( ::modchart::ModManager modMgr, ::modchart::Modifier parent){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_24_new)
HXLINE(  32)		this->_hx_far = 2;
HXLINE(  31)		this->_hx_near = 0;
HXLINE(  30)		this->fov = (::Math_obj::PI / ( (Float)(2) ));
HXLINE(  24)		super::__construct(modMgr,parent);
            	}

Dynamic PerspectiveModifier_obj::__CreateEmpty() { return new PerspectiveModifier_obj; }

void *PerspectiveModifier_obj::_hx_vtable = 0;

Dynamic PerspectiveModifier_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PerspectiveModifier_obj > _hx_result = new PerspectiveModifier_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool PerspectiveModifier_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1c83aa7b) {
		if (inClassId<=(int)0x0ce062e5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0ce062e5;
		} else {
			return inClassId==(int)0x1c83aa7b;
		}
	} else {
		return inClassId==(int)0x4386e937;
	}
}

::String PerspectiveModifier_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_25_getName)
HXDLIN(  25)		return HX_("perspectiveDONTUSE",3a,02,a1,46);
            	}


int PerspectiveModifier_obj::getOrder(){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_27_getOrder)
HXDLIN(  27)		return (1000 + 100);
            	}


bool PerspectiveModifier_obj::shouldExecute(int player,Float val){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_28_shouldExecute)
HXDLIN(  28)		return true;
            	}


Float PerspectiveModifier_obj::FastTan(Float rad){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_36_FastTan)
HXDLIN(  36)		Float n = rad;
HXDLIN(  36)		n = (n * ((Float)0.3183098862));
HXDLIN(  36)		if ((n > 1)) {
HXDLIN(  36)			n = (n - ( (Float)(((::Math_obj::ceil(n) >> 1) << 1)) ));
            		}
            		else {
HXDLIN(  36)			if ((n < -1)) {
HXDLIN(  36)				n = (n + ((::Math_obj::ceil(-(n)) >> 1) << 1));
            			}
            		}
HXDLIN(  36)		Float _hx_tmp;
HXDLIN(  36)		if ((n > 0)) {
HXDLIN(  36)			_hx_tmp = (n * (((Float)3.1) + (n * (((Float)0.5) + (n * (((Float)-7.2) + (n * ((Float)3.6))))))));
            		}
            		else {
HXDLIN(  36)			_hx_tmp = (n * (((Float)3.1) - (n * (((Float)0.5) + (n * (((Float)7.2) + (n * ((Float)3.6))))))));
            		}
HXDLIN(  36)		Float n1 = (rad + ((Float)1.570796327));
HXDLIN(  36)		n1 = (n1 * ((Float)0.3183098862));
HXDLIN(  36)		if ((n1 > 1)) {
HXDLIN(  36)			n1 = (n1 - ( (Float)(((::Math_obj::ceil(n1) >> 1) << 1)) ));
            		}
            		else {
HXDLIN(  36)			if ((n1 < -1)) {
HXDLIN(  36)				n1 = (n1 + ((::Math_obj::ceil(-(n1)) >> 1) << 1));
            			}
            		}
HXDLIN(  36)		Float _hx_tmp1;
HXDLIN(  36)		if ((n1 > 0)) {
HXDLIN(  36)			_hx_tmp1 = (n1 * (((Float)3.1) + (n1 * (((Float)0.5) + (n1 * (((Float)-7.2) + (n1 * ((Float)3.6))))))));
            		}
            		else {
HXDLIN(  36)			_hx_tmp1 = (n1 * (((Float)3.1) - (n1 * (((Float)0.5) + (n1 * (((Float)7.2) + (n1 * ((Float)3.6))))))));
            		}
HXDLIN(  36)		return (_hx_tmp / _hx_tmp1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PerspectiveModifier_obj,FastTan,return )

 ::math::Vector3 PerspectiveModifier_obj::getVector(Float curZ, ::math::Vector3 pos){
            	HX_GC_STACKFRAME(&_hx_pos_32fa8016a810fe3e_40_getVector)
HXLINE(  41)		 ::math::Vector3 halfOffset =  ::math::Vector3_obj::__alloc( HX_CTX ,(( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )),(( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) )),null());
HXLINE(  42)		 ::math::Vector3 result = null();
HXDLIN(  42)		if (::hx::IsNull( result )) {
HXLINE(  42)			result =  ::math::Vector3_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXDLIN(  42)		{
HXLINE(  42)			result->x = (pos->x - halfOffset->x);
HXDLIN(  42)			result->y = (pos->y - halfOffset->y);
HXDLIN(  42)			result->z = (pos->z - halfOffset->z);
            		}
HXDLIN(  42)		pos = result;
HXLINE(  43)		Float oX = pos->x;
HXLINE(  44)		Float oY = pos->y;
HXLINE(  52)		int aspect = 1;
HXLINE(  54)		Float shit = (curZ - ( (Float)(1) ));
HXLINE(  55)		if ((shit > 0)) {
HXLINE(  55)			shit = ( (Float)(0) );
            		}
HXLINE(  57)		Float ta = this->FastTan((this->fov / ( (Float)(2) )));
HXLINE(  58)		Float x = ((oX * ( (Float)(aspect) )) / ta);
HXLINE(  59)		Float y = (oY / ta);
HXLINE(  60)		Float a = (( (Float)((this->_hx_near + this->_hx_far)) ) / ( (Float)((this->_hx_near - this->_hx_far)) ));
HXLINE(  61)		Float b = (( (Float)(((2 * this->_hx_near) * this->_hx_far)) ) / ( (Float)((this->_hx_near - this->_hx_far)) ));
HXLINE(  62)		Float z = ((a * shit) + b);
HXLINE(  64)		 ::math::Vector3 _this =  ::math::Vector3_obj::__alloc( HX_CTX ,(x / z),(y / z),z);
HXDLIN(  64)		 ::math::Vector3 result1 = null();
HXDLIN(  64)		if (::hx::IsNull( result1 )) {
HXLINE(  64)			result1 =  ::math::Vector3_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXDLIN(  64)		{
HXLINE(  64)			result1->x = (_this->x + halfOffset->x);
HXDLIN(  64)			result1->y = (_this->y + halfOffset->y);
HXDLIN(  64)			result1->z = (_this->z + halfOffset->z);
            		}
HXDLIN(  64)		 ::math::Vector3 returnedVector = result1;
HXLINE(  66)		return returnedVector;
            	}


HX_DEFINE_DYNAMIC_FUNC2(PerspectiveModifier_obj,getVector,return )

 ::math::Vector3 PerspectiveModifier_obj::getPos(Float time,Float visualDiff,Float timeDiff,Float beat, ::math::Vector3 pos,int data,int player, ::flixel::FlxSprite obj){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_78_getPos)
HXDLIN(  78)		return this->getVector(pos->z,pos);
            	}


void PerspectiveModifier_obj::updateReceptor(Float beat, ::StrumNote receptor, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_82_updateReceptor)
HXDLIN(  82)		 ::flixel::math::FlxBasePoint this1 = receptor->scale;
HXDLIN(  82)		Float x = (( (Float)(1) ) / pos->z);
HXDLIN(  82)		 ::Dynamic y = null();
HXDLIN(  82)		if (::hx::IsNull( y )) {
HXDLIN(  82)			y = x;
            		}
HXDLIN(  82)		this1->set_x((this1->x * x));
HXDLIN(  82)		this1->set_y((this1->y * ( (Float)(y) )));
            	}


void PerspectiveModifier_obj::updateNote(Float beat, ::Note note, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_32fa8016a810fe3e_87_updateNote)
HXDLIN(  87)		 ::flixel::math::FlxBasePoint this1 = note->scale;
HXDLIN(  87)		Float x = (( (Float)(1) ) / pos->z);
HXDLIN(  87)		 ::Dynamic y = null();
HXDLIN(  87)		if (::hx::IsNull( y )) {
HXDLIN(  87)			y = x;
            		}
HXDLIN(  87)		this1->set_x((this1->x * x));
HXDLIN(  87)		this1->set_y((this1->y * ( (Float)(y) )));
            	}



::hx::ObjectPtr< PerspectiveModifier_obj > PerspectiveModifier_obj::__new( ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	::hx::ObjectPtr< PerspectiveModifier_obj > __this = new PerspectiveModifier_obj();
	__this->__construct(modMgr,parent);
	return __this;
}

::hx::ObjectPtr< PerspectiveModifier_obj > PerspectiveModifier_obj::__alloc(::hx::Ctx *_hx_ctx, ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	PerspectiveModifier_obj *__this = (PerspectiveModifier_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PerspectiveModifier_obj), true, "modchart.modifiers.PerspectiveModifier"));
	*(void **)__this = PerspectiveModifier_obj::_hx_vtable;
	__this->__construct(modMgr,parent);
	return __this;
}

PerspectiveModifier_obj::PerspectiveModifier_obj()
{
}

::hx::Val PerspectiveModifier_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fov") ) { return ::hx::Val( fov ); }
		if (HX_FIELD_EQ(inName,"far") ) { return ::hx::Val( _hx_far ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"near") ) { return ::hx::Val( _hx_near ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"getPos") ) { return ::hx::Val( getPos_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return ::hx::Val( getName_dyn() ); }
		if (HX_FIELD_EQ(inName,"FastTan") ) { return ::hx::Val( FastTan_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getOrder") ) { return ::hx::Val( getOrder_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"getVector") ) { return ::hx::Val( getVector_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"updateNote") ) { return ::hx::Val( updateNote_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"shouldExecute") ) { return ::hx::Val( shouldExecute_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateReceptor") ) { return ::hx::Val( updateReceptor_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val PerspectiveModifier_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fov") ) { fov=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"far") ) { _hx_far=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"near") ) { _hx_near=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PerspectiveModifier_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("fov",0d,c7,4d,00));
	outFields->push(HX_("near",e8,70,02,49));
	outFields->push(HX_("far",d7,ba,4d,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PerspectiveModifier_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(PerspectiveModifier_obj,fov),HX_("fov",0d,c7,4d,00)},
	{::hx::fsInt,(int)offsetof(PerspectiveModifier_obj,_hx_near),HX_("near",e8,70,02,49)},
	{::hx::fsInt,(int)offsetof(PerspectiveModifier_obj,_hx_far),HX_("far",d7,ba,4d,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *PerspectiveModifier_obj_sStaticStorageInfo = 0;
#endif

static ::String PerspectiveModifier_obj_sMemberFields[] = {
	HX_("getName",01,22,82,1b),
	HX_("getOrder",18,00,f8,94),
	HX_("shouldExecute",42,46,a1,bc),
	HX_("fov",0d,c7,4d,00),
	HX_("near",e8,70,02,49),
	HX_("far",d7,ba,4d,00),
	HX_("FastTan",05,01,7e,ab),
	HX_("getVector",f9,39,b4,13),
	HX_("getPos",9e,96,24,a3),
	HX_("updateReceptor",e5,3a,c6,1c),
	HX_("updateNote",9b,02,bf,01),
	::String(null()) };

::hx::Class PerspectiveModifier_obj::__mClass;

void PerspectiveModifier_obj::__register()
{
	PerspectiveModifier_obj _hx_dummy;
	PerspectiveModifier_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.modifiers.PerspectiveModifier",8f,c3,4b,ba);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PerspectiveModifier_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PerspectiveModifier_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PerspectiveModifier_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PerspectiveModifier_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
} // end namespace modifiers
