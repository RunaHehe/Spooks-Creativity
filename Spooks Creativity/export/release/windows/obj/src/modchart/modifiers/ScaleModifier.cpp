// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StrumNote
#include <StrumNote.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ScaleModifier
#include <modchart/modifiers/ScaleModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cb44bf5a121d8336_7_new,"modchart.modifiers.ScaleModifier","new",0xadf0810f,"modchart.modifiers.ScaleModifier.new","modchart/modifiers/ScaleModifier.hx",7,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_8_getName,"modchart.modifiers.ScaleModifier","getName",0x10565630,"modchart.modifiers.ScaleModifier.getName","modchart/modifiers/ScaleModifier.hx",8,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_9_getOrder,"modchart.modifiers.ScaleModifier","getOrder",0xd9d17509,"modchart.modifiers.ScaleModifier.getOrder","modchart/modifiers/ScaleModifier.hx",9,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_12_lerp,"modchart.modifiers.ScaleModifier","lerp",0x832dfae8,"modchart.modifiers.ScaleModifier.lerp","modchart/modifiers/ScaleModifier.hx",12,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_15_getScale,"modchart.modifiers.ScaleModifier","getScale",0x1d7f5305,"modchart.modifiers.ScaleModifier.getScale","modchart/modifiers/ScaleModifier.hx",15,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_47_shouldExecute,"modchart.modifiers.ScaleModifier","shouldExecute",0x070547b1,"modchart.modifiers.ScaleModifier.shouldExecute","modchart/modifiers/ScaleModifier.hx",47,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_50_ignorePos,"modchart.modifiers.ScaleModifier","ignorePos",0xa840b191,"modchart.modifiers.ScaleModifier.ignorePos","modchart/modifiers/ScaleModifier.hx",50,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_53_ignoreUpdateReceptor,"modchart.modifiers.ScaleModifier","ignoreUpdateReceptor",0x81751e08,"modchart.modifiers.ScaleModifier.ignoreUpdateReceptor","modchart/modifiers/ScaleModifier.hx",53,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_56_ignoreUpdateNote,"modchart.modifiers.ScaleModifier","ignoreUpdateNote",0xdf0ed83e,"modchart.modifiers.ScaleModifier.ignoreUpdateNote","modchart/modifiers/ScaleModifier.hx",56,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_59_updateNote,"modchart.modifiers.ScaleModifier","updateNote",0x479455cc,"modchart.modifiers.ScaleModifier.updateNote","modchart/modifiers/ScaleModifier.hx",59,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_68_updateReceptor,"modchart.modifiers.ScaleModifier","updateReceptor",0xe9e37a96,"modchart.modifiers.ScaleModifier.updateReceptor","modchart/modifiers/ScaleModifier.hx",68,0xb6572483)
HX_LOCAL_STACK_FRAME(_hx_pos_cb44bf5a121d8336_75_getSubmods,"modchart.modifiers.ScaleModifier","getSubmods",0xc0c2162c,"modchart.modifiers.ScaleModifier.getSubmods","modchart/modifiers/ScaleModifier.hx",75,0xb6572483)
static const ::String _hx_array_data_2a214d9d_13[] = {
	HX_("squish",87,13,f8,58),HX_("stretch",05,3e,53,f6),HX_("miniX",e1,75,68,08),HX_("miniY",e2,75,68,08),
};
namespace modchart{
namespace modifiers{

void ScaleModifier_obj::__construct( ::modchart::ModManager modMgr, ::modchart::Modifier parent){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_7_new)
HXDLIN(   7)		super::__construct(modMgr,parent);
            	}

Dynamic ScaleModifier_obj::__CreateEmpty() { return new ScaleModifier_obj; }

void *ScaleModifier_obj::_hx_vtable = 0;

Dynamic ScaleModifier_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ScaleModifier_obj > _hx_result = new ScaleModifier_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ScaleModifier_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0ce062e5) {
		if (inClassId<=(int)0x0603d6c1) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0603d6c1;
		} else {
			return inClassId==(int)0x0ce062e5;
		}
	} else {
		return inClassId==(int)0x4386e937;
	}
}

::String ScaleModifier_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_8_getName)
HXDLIN(   8)		return HX_("mini",97,4e,5c,48);
            	}


int ScaleModifier_obj::getOrder(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_9_getOrder)
HXDLIN(   9)		return -3;
            	}


Float ScaleModifier_obj::lerp(Float a,Float b,Float c){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_12_lerp)
HXDLIN(  12)		return (a + ((b - a) * c));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ScaleModifier_obj,lerp,return )

 ::flixel::math::FlxBasePoint ScaleModifier_obj::getScale( ::Dynamic sprite, ::flixel::math::FlxBasePoint scale,int data,int player){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_15_getScale)
HXLINE(  16)		Float y = scale->y;
HXLINE(  17)		{
HXLINE(  17)			Float scale1 = scale->x;
HXDLIN(  17)			scale->set_x((scale1 * (( (Float)(1) ) - this->getValue(player))));
            		}
HXLINE(  18)		{
HXLINE(  18)			Float scale2 = scale->y;
HXDLIN(  18)			scale->set_y((scale2 * (( (Float)(1) ) - this->getValue(player))));
            		}
HXLINE(  19)		Float miniX = this->getSubmodValue(HX_("miniX",e1,75,68,08),player);
HXDLIN(  19)		Float miniX1 = (miniX + this->getSubmodValue(((HX_("mini",97,4e,5c,48) + data) + HX_("X",58,00,00,00)),player));
HXLINE(  20)		Float miniY = this->getSubmodValue(HX_("miniY",e2,75,68,08),player);
HXDLIN(  20)		Float miniY1 = (miniY + this->getSubmodValue(((HX_("mini",97,4e,5c,48) + data) + HX_("Y",59,00,00,00)),player));
HXLINE(  22)		scale->set_x((scale->x * (( (Float)(1) ) - miniX1)));
HXLINE(  23)		scale->set_y((scale->y * (( (Float)(1) ) - miniY1)));
HXLINE(  24)		int angle = 0;
HXLINE(  26)		Float stretch = this->getSubmodValue(HX_("stretch",05,3e,53,f6),player);
HXDLIN(  26)		Float stretch1 = (stretch + this->getSubmodValue((HX_("stretch",05,3e,53,f6) + data),player));
HXLINE(  27)		Float squish = this->getSubmodValue(HX_("squish",87,13,f8,58),player);
HXDLIN(  27)		Float squish1 = (squish + this->getSubmodValue((HX_("squish",87,13,f8,58) + data),player));
HXLINE(  29)		Float stretchX = (1 + (((Float)-0.5) * stretch1));
HXLINE(  30)		Float stretchY = (1 + stretch1);
HXLINE(  32)		Float squishX = (1 + squish1);
HXLINE(  33)		Float squishY = (1 + (((Float)-0.5) * squish1));
HXLINE(  35)		scale->set_x((scale->x * ((::Math_obj::sin(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * squishY) + (::Math_obj::cos(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * squishX))));
HXLINE(  36)		scale->set_x((scale->x * ((::Math_obj::sin(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * stretchY) + (::Math_obj::cos(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * stretchX))));
HXLINE(  38)		scale->set_y((scale->y * ((::Math_obj::cos(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * stretchY) + (::Math_obj::sin(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * stretchX))));
HXLINE(  39)		scale->set_y((scale->y * ((::Math_obj::cos(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * squishY) + (::Math_obj::sin(((( (Float)(angle) ) * ::Math_obj::PI) / ( (Float)(180) ))) * squishX))));
HXLINE(  40)		bool _hx_tmp;
HXDLIN(  40)		if (::Std_obj::isOfType(sprite,::hx::ClassOf< ::Note >())) {
HXLINE(  40)			_hx_tmp = ( (bool)(sprite->__Field(HX_("isSustainNote",6b,1e,77,c3),::hx::paccDynamic)) );
            		}
            		else {
HXLINE(  40)			_hx_tmp = false;
            		}
HXDLIN(  40)		if (_hx_tmp) {
HXLINE(  41)			scale->set_y(y);
            		}
HXLINE(  43)		return scale;
            	}


HX_DEFINE_DYNAMIC_FUNC4(ScaleModifier_obj,getScale,return )

bool ScaleModifier_obj::shouldExecute(int player,Float val){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_47_shouldExecute)
HXDLIN(  47)		return true;
            	}


bool ScaleModifier_obj::ignorePos(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_50_ignorePos)
HXDLIN(  50)		return true;
            	}


bool ScaleModifier_obj::ignoreUpdateReceptor(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_53_ignoreUpdateReceptor)
HXDLIN(  53)		return false;
            	}


bool ScaleModifier_obj::ignoreUpdateNote(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_56_ignoreUpdateNote)
HXDLIN(  56)		return false;
            	}


void ScaleModifier_obj::updateNote(Float beat, ::Note note, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_59_updateNote)
HXLINE(  60)		Float x = note->defScale->x;
HXDLIN(  60)		Float y = note->defScale->y;
HXDLIN(  60)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(  60)		point->_inPool = false;
HXDLIN(  60)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(  60)		point1->_weak = true;
HXDLIN(  60)		 ::flixel::math::FlxBasePoint scale = this->getScale(note,point1,note->noteData,player);
HXLINE(  61)		if (note->isSustainNote) {
HXLINE(  61)			scale->set_y(note->defScale->y);
            		}
HXLINE(  63)		{
HXLINE(  63)			 ::flixel::math::FlxBasePoint this1 = note->scale;
HXDLIN(  63)			{
HXLINE(  63)				Float y1 = scale->y;
HXDLIN(  63)				this1->set_x(scale->x);
HXDLIN(  63)				this1->set_y(y1);
            			}
HXDLIN(  63)			if (scale->_weak) {
HXLINE(  63)				scale->put();
            			}
            		}
HXLINE(  64)		if (scale->_weak) {
HXLINE(  64)			scale->put();
            		}
            	}


void ScaleModifier_obj::updateReceptor(Float beat, ::StrumNote receptor, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_68_updateReceptor)
HXLINE(  69)		Float x = receptor->defScale->x;
HXDLIN(  69)		Float y = receptor->defScale->y;
HXDLIN(  69)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(  69)		point->_inPool = false;
HXDLIN(  69)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(  69)		point1->_weak = true;
HXDLIN(  69)		 ::flixel::math::FlxBasePoint scale = this->getScale(receptor,point1,receptor->noteData,player);
HXLINE(  70)		{
HXLINE(  70)			 ::flixel::math::FlxBasePoint this1 = receptor->scale;
HXDLIN(  70)			{
HXLINE(  70)				Float y1 = scale->y;
HXDLIN(  70)				this1->set_x(scale->x);
HXDLIN(  70)				this1->set_y(y1);
            			}
HXDLIN(  70)			if (scale->_weak) {
HXLINE(  70)				scale->put();
            			}
            		}
HXLINE(  71)		if (scale->_weak) {
HXLINE(  71)			scale->put();
            		}
            	}


::Array< ::String > ScaleModifier_obj::getSubmods(){
            	HX_STACKFRAME(&_hx_pos_cb44bf5a121d8336_75_getSubmods)
HXLINE(  76)		::Array< ::String > subMods = ::Array_obj< ::String >::fromData( _hx_array_data_2a214d9d_13,4);
HXLINE(  78)		::Array< ::Dynamic> receptors = this->modMgr->receptors->__get(0).StaticCast< ::Array< ::Dynamic> >();
HXLINE(  79)		int kNum = receptors->length;
HXLINE(  80)		{
HXLINE(  80)			int _g = 0;
HXDLIN(  80)			while((_g < 4)){
HXLINE(  80)				_g = (_g + 1);
HXDLIN(  80)				int i = (_g - 1);
HXLINE(  82)				subMods->push(((HX_("mini",97,4e,5c,48) + i) + HX_("X",58,00,00,00)));
HXLINE(  83)				subMods->push(((HX_("mini",97,4e,5c,48) + i) + HX_("Y",59,00,00,00)));
HXLINE(  84)				subMods->push((HX_("squish",87,13,f8,58) + i));
HXLINE(  85)				subMods->push((HX_("stretch",05,3e,53,f6) + i));
            			}
            		}
HXLINE(  87)		return subMods;
            	}



::hx::ObjectPtr< ScaleModifier_obj > ScaleModifier_obj::__new( ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	::hx::ObjectPtr< ScaleModifier_obj > __this = new ScaleModifier_obj();
	__this->__construct(modMgr,parent);
	return __this;
}

::hx::ObjectPtr< ScaleModifier_obj > ScaleModifier_obj::__alloc(::hx::Ctx *_hx_ctx, ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	ScaleModifier_obj *__this = (ScaleModifier_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ScaleModifier_obj), true, "modchart.modifiers.ScaleModifier"));
	*(void **)__this = ScaleModifier_obj::_hx_vtable;
	__this->__construct(modMgr,parent);
	return __this;
}

ScaleModifier_obj::ScaleModifier_obj()
{
}

::hx::Val ScaleModifier_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { return ::hx::Val( lerp_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return ::hx::Val( getName_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getOrder") ) { return ::hx::Val( getOrder_dyn() ); }
		if (HX_FIELD_EQ(inName,"getScale") ) { return ::hx::Val( getScale_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"ignorePos") ) { return ::hx::Val( ignorePos_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"updateNote") ) { return ::hx::Val( updateNote_dyn() ); }
		if (HX_FIELD_EQ(inName,"getSubmods") ) { return ::hx::Val( getSubmods_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"shouldExecute") ) { return ::hx::Val( shouldExecute_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateReceptor") ) { return ::hx::Val( updateReceptor_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"ignoreUpdateNote") ) { return ::hx::Val( ignoreUpdateNote_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"ignoreUpdateReceptor") ) { return ::hx::Val( ignoreUpdateReceptor_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ScaleModifier_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ScaleModifier_obj_sStaticStorageInfo = 0;
#endif

static ::String ScaleModifier_obj_sMemberFields[] = {
	HX_("getName",01,22,82,1b),
	HX_("getOrder",18,00,f8,94),
	HX_("lerp",77,12,b0,47),
	HX_("getScale",14,de,a5,d8),
	HX_("shouldExecute",42,46,a1,bc),
	HX_("ignorePos",a2,d3,d3,ae),
	HX_("ignoreUpdateReceptor",97,83,07,f8),
	HX_("ignoreUpdateNote",4d,8a,5d,a0),
	HX_("updateNote",9b,02,bf,01),
	HX_("updateReceptor",e5,3a,c6,1c),
	HX_("getSubmods",fb,c2,ec,7a),
	::String(null()) };

::hx::Class ScaleModifier_obj::__mClass;

void ScaleModifier_obj::__register()
{
	ScaleModifier_obj _hx_dummy;
	ScaleModifier_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.modifiers.ScaleModifier",9d,4d,21,2a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ScaleModifier_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ScaleModifier_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ScaleModifier_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ScaleModifier_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
} // end namespace modifiers
