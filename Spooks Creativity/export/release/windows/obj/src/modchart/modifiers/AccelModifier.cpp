// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_AccelModifier
#include <modchart/modifiers/AccelModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0b131c903827d69e_10_new,"modchart.modifiers.AccelModifier","new",0x3849236d,"modchart.modifiers.AccelModifier.new","modchart/modifiers/AccelModifier.hx",10,0x1e4777e5)
HX_LOCAL_STACK_FRAME(_hx_pos_0b131c903827d69e_12_lerp,"modchart.modifiers.AccelModifier","lerp",0x06636aca,"modchart.modifiers.AccelModifier.lerp","modchart/modifiers/AccelModifier.hx",12,0x1e4777e5)
HX_LOCAL_STACK_FRAME(_hx_pos_0b131c903827d69e_16_getName,"modchart.modifiers.AccelModifier","getName",0xb0527f8e,"modchart.modifiers.AccelModifier.getName","modchart/modifiers/AccelModifier.hx",16,0x1e4777e5)
HX_LOCAL_STACK_FRAME(_hx_pos_0b131c903827d69e_18_getPos,"modchart.modifiers.AccelModifier","getPos",0xf79ce9b1,"modchart.modifiers.AccelModifier.getPos","modchart/modifiers/AccelModifier.hx",18,0x1e4777e5)
HX_LOCAL_STACK_FRAME(_hx_pos_0b131c903827d69e_47_getSubmods,"modchart.modifiers.AccelModifier","getSubmods",0x9e279b8e,"modchart.modifiers.AccelModifier.getSubmods","modchart/modifiers/AccelModifier.hx",47,0x1e4777e5)
static const ::String _hx_array_data_c6e5e8fb_5[] = {
	HX_("brake",6b,24,e9,b8),HX_("wave",b9,65,f2,4e),
};
namespace modchart{
namespace modifiers{

void AccelModifier_obj::__construct( ::modchart::ModManager modMgr, ::modchart::Modifier parent){
            	HX_STACKFRAME(&_hx_pos_0b131c903827d69e_10_new)
HXDLIN(  10)		super::__construct(modMgr,parent);
            	}

Dynamic AccelModifier_obj::__CreateEmpty() { return new AccelModifier_obj; }

void *AccelModifier_obj::_hx_vtable = 0;

Dynamic AccelModifier_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AccelModifier_obj > _hx_result = new AccelModifier_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool AccelModifier_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1b9496e7) {
		if (inClassId<=(int)0x0ce062e5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0ce062e5;
		} else {
			return inClassId==(int)0x1b9496e7;
		}
	} else {
		return inClassId==(int)0x4386e937;
	}
}

Float AccelModifier_obj::lerp(Float a,Float b,Float c){
            	HX_STACKFRAME(&_hx_pos_0b131c903827d69e_12_lerp)
HXDLIN(  12)		return (a + ((b - a) * c));
            	}


HX_DEFINE_DYNAMIC_FUNC3(AccelModifier_obj,lerp,return )

::String AccelModifier_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_0b131c903827d69e_16_getName)
HXDLIN(  16)		return HX_("boost",23,27,f8,b6);
            	}


 ::math::Vector3 AccelModifier_obj::getPos(Float time,Float visualDiff,Float timeDiff,Float beat, ::math::Vector3 pos,int data,int player, ::flixel::FlxSprite obj){
            	HX_STACKFRAME(&_hx_pos_0b131c903827d69e_18_getPos)
HXLINE(  19)		Float wave = this->getSubmodValue(HX_("wave",b9,65,f2,4e),player);
HXLINE(  20)		Float brake = this->getSubmodValue(HX_("brake",6b,24,e9,b8),player);
HXLINE(  21)		Float boost = this->getValue(player);
HXLINE(  22)		int effectHeight = 500;
HXLINE(  24)		Float yAdjust = ( (Float)(0) );
HXLINE(  25)		 ::Dynamic reverse = this->modMgr->_hx_register->get(HX_("reverse",22,39,fc,1a));
HXLINE(  26)		Float reversePercent = ( (Float)(reverse->__Field(HX_("getReverseValue",a5,b0,07,6b),::hx::paccDynamic)(data,player)) );
HXLINE(  27)		Float mult = (((reversePercent * ( (Float)(-2) )) / ( (Float)(1) )) + 1);
HXLINE(  29)		if ((brake != 0)) {
HXLINE(  30)			Float scale = (visualDiff / ( (Float)(effectHeight) ));
HXLINE(  31)			Float off = (visualDiff * scale);
HXLINE(  32)			Float n = (brake * (off - visualDiff));
HXDLIN(  32)			if ((n > 400)) {
HXLINE(  32)				n = ( (Float)(400) );
            			}
HXDLIN(  32)			if ((n < -400)) {
HXLINE(  32)				n = ( (Float)(-400) );
            			}
HXDLIN(  32)			yAdjust = (yAdjust + n);
            		}
HXLINE(  35)		if ((boost != 0)) {
HXLINE(  37)			Float off1 = ((visualDiff * ((Float)1.5)) / ((visualDiff + (( (Float)(effectHeight) ) / ((Float)1.2))) / ( (Float)(effectHeight) )));
HXLINE(  38)			Float n1 = (boost * (off1 - visualDiff));
HXDLIN(  38)			if ((n1 > 400)) {
HXLINE(  38)				n1 = ( (Float)(400) );
            			}
HXDLIN(  38)			if ((n1 < -400)) {
HXLINE(  38)				n1 = ( (Float)(-400) );
            			}
HXDLIN(  38)			yAdjust = (yAdjust + n1);
            		}
HXLINE(  41)		Float n2 = (visualDiff / ( (Float)(38) ));
HXDLIN(  41)		n2 = (n2 * ((Float)0.3183098862));
HXDLIN(  41)		if ((n2 > 1)) {
HXLINE(  41)			n2 = (n2 - ( (Float)(((::Math_obj::ceil(n2) >> 1) << 1)) ));
            		}
            		else {
HXLINE(  41)			if ((n2 < -1)) {
HXLINE(  41)				n2 = (n2 + ((::Math_obj::ceil(-(n2)) >> 1) << 1));
            			}
            		}
HXDLIN(  41)		Float yAdjust1;
HXDLIN(  41)		if ((n2 > 0)) {
HXLINE(  41)			yAdjust1 = (n2 * (((Float)3.1) + (n2 * (((Float)0.5) + (n2 * (((Float)-7.2) + (n2 * ((Float)3.6))))))));
            		}
            		else {
HXLINE(  41)			yAdjust1 = (n2 * (((Float)3.1) - (n2 * (((Float)0.5) + (n2 * (((Float)7.2) + (n2 * ((Float)3.6))))))));
            		}
HXDLIN(  41)		yAdjust = (yAdjust + ((wave * ( (Float)(20) )) * yAdjust1));
HXLINE(  43)		 ::math::Vector3 pos1 = pos;
HXDLIN(  43)		pos1->y = (pos1->y + (yAdjust * mult));
HXLINE(  44)		return pos;
            	}


::Array< ::String > AccelModifier_obj::getSubmods(){
            	HX_STACKFRAME(&_hx_pos_0b131c903827d69e_47_getSubmods)
HXLINE(  48)		::Array< ::String > subMods = ::Array_obj< ::String >::fromData( _hx_array_data_c6e5e8fb_5,2);
HXLINE(  49)		return subMods;
            	}



::hx::ObjectPtr< AccelModifier_obj > AccelModifier_obj::__new( ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	::hx::ObjectPtr< AccelModifier_obj > __this = new AccelModifier_obj();
	__this->__construct(modMgr,parent);
	return __this;
}

::hx::ObjectPtr< AccelModifier_obj > AccelModifier_obj::__alloc(::hx::Ctx *_hx_ctx, ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	AccelModifier_obj *__this = (AccelModifier_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(AccelModifier_obj), true, "modchart.modifiers.AccelModifier"));
	*(void **)__this = AccelModifier_obj::_hx_vtable;
	__this->__construct(modMgr,parent);
	return __this;
}

AccelModifier_obj::AccelModifier_obj()
{
}

::hx::Val AccelModifier_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { return ::hx::Val( lerp_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"getPos") ) { return ::hx::Val( getPos_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return ::hx::Val( getName_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getSubmods") ) { return ::hx::Val( getSubmods_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *AccelModifier_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *AccelModifier_obj_sStaticStorageInfo = 0;
#endif

static ::String AccelModifier_obj_sMemberFields[] = {
	HX_("lerp",77,12,b0,47),
	HX_("getName",01,22,82,1b),
	HX_("getPos",9e,96,24,a3),
	HX_("getSubmods",fb,c2,ec,7a),
	::String(null()) };

::hx::Class AccelModifier_obj::__mClass;

void AccelModifier_obj::__register()
{
	AccelModifier_obj _hx_dummy;
	AccelModifier_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.modifiers.AccelModifier",fb,e8,e5,c6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AccelModifier_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AccelModifier_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AccelModifier_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AccelModifier_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
} // end namespace modifiers
