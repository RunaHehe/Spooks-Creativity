// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_CoolUtil
#include <CoolUtil.h>
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_RotateModifier
#include <modchart/modifiers/RotateModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_771b475b1869cc73_23_new,"modchart.modifiers.RotateModifier","new",0x34167fa8,"modchart.modifiers.RotateModifier.new","modchart/modifiers/RotateModifier.hx",23,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_13_getName,"modchart.modifiers.RotateModifier","getName",0xeca21549,"modchart.modifiers.RotateModifier.getName","modchart/modifiers/RotateModifier.hx",13,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_16_getOrder,"modchart.modifiers.RotateModifier","getOrder",0xbfccebd0,"modchart.modifiers.RotateModifier.getOrder","modchart/modifiers/RotateModifier.hx",16,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_19_lerp,"modchart.modifiers.RotateModifier","lerp",0x5e46c22f,"modchart.modifiers.RotateModifier.lerp","modchart/modifiers/RotateModifier.hx",19,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_31_rotateV3,"modchart.modifiers.RotateModifier","rotateV3",0x335809f0,"modchart.modifiers.RotateModifier.rotateV3","modchart/modifiers/RotateModifier.hx",31,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_49_getPos,"modchart.modifiers.RotateModifier","getPos",0x9090a456,"modchart.modifiers.RotateModifier.getPos","modchart/modifiers/RotateModifier.hx",49,0x1a71f746)
HX_LOCAL_STACK_FRAME(_hx_pos_771b475b1869cc73_62_getSubmods,"modchart.modifiers.RotateModifier","getSubmods",0xb59e0cb3,"modchart.modifiers.RotateModifier.getSubmods","modchart/modifiers/RotateModifier.hx",62,0x1a71f746)
namespace modchart{
namespace modifiers{

void RotateModifier_obj::__construct( ::modchart::ModManager modMgr,::String __o_prefix, ::math::Vector3 origin, ::modchart::Modifier parent){
            		::String prefix = __o_prefix;
            		if (::hx::IsNull(__o_prefix)) prefix = HX_("",00,00,00,00);
            	HX_STACKFRAME(&_hx_pos_771b475b1869cc73_23_new)
HXLINE(  24)		this->prefix = prefix;
HXLINE(  25)		this->daOrigin = origin;
HXLINE(  26)		super::__construct(modMgr,parent);
            	}

Dynamic RotateModifier_obj::__CreateEmpty() { return new RotateModifier_obj; }

void *RotateModifier_obj::_hx_vtable = 0;

Dynamic RotateModifier_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RotateModifier_obj > _hx_result = new RotateModifier_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool RotateModifier_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0ce062e5) {
		if (inClassId<=(int)0x0b814212) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0b814212;
		} else {
			return inClassId==(int)0x0ce062e5;
		}
	} else {
		return inClassId==(int)0x4386e937;
	}
}

::String RotateModifier_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_771b475b1869cc73_13_getName)
HXDLIN(  13)		return ((HX_("",00,00,00,00) + this->prefix) + HX_("rotateX",9d,49,1d,f1));
            	}


int RotateModifier_obj::getOrder(){
            	HX_STACKFRAME(&_hx_pos_771b475b1869cc73_16_getOrder)
HXDLIN(  16)		return (1000 + 2);
            	}


Float RotateModifier_obj::lerp(Float a,Float b,Float c){
            	HX_STACKFRAME(&_hx_pos_771b475b1869cc73_19_lerp)
HXDLIN(  19)		return (a + ((b - a) * c));
            	}


HX_DEFINE_DYNAMIC_FUNC3(RotateModifier_obj,lerp,return )

 ::math::Vector3 RotateModifier_obj::rotateV3( ::math::Vector3 vec,Float xA,Float yA,Float zA){
            	HX_GC_STACKFRAME(&_hx_pos_771b475b1869cc73_31_rotateV3)
HXLINE(  32)		 ::flixel::math::FlxBasePoint rotateZ = ::CoolUtil_obj::rotate(vec->x,vec->y,zA,null());
HXLINE(  33)		 ::math::Vector3 offZ =  ::math::Vector3_obj::__alloc( HX_CTX ,rotateZ->x,rotateZ->y,vec->z);
HXLINE(  35)		 ::flixel::math::FlxBasePoint rotateX = ::CoolUtil_obj::rotate(offZ->z,offZ->y,xA,null());
HXLINE(  36)		 ::math::Vector3 offX =  ::math::Vector3_obj::__alloc( HX_CTX ,offZ->x,rotateX->y,rotateX->x);
HXLINE(  38)		 ::flixel::math::FlxBasePoint rotateY = ::CoolUtil_obj::rotate(offX->x,offX->z,yA,null());
HXLINE(  39)		 ::math::Vector3 offY =  ::math::Vector3_obj::__alloc( HX_CTX ,rotateY->x,offX->y,rotateY->y);
HXLINE(  41)		if (rotateZ->_weak) {
HXLINE(  41)			rotateZ->put();
            		}
HXLINE(  42)		if (rotateX->_weak) {
HXLINE(  42)			rotateX->put();
            		}
HXLINE(  43)		if (rotateY->_weak) {
HXLINE(  43)			rotateY->put();
            		}
HXLINE(  45)		return offY;
            	}


HX_DEFINE_DYNAMIC_FUNC4(RotateModifier_obj,rotateV3,return )

 ::math::Vector3 RotateModifier_obj::getPos(Float time,Float visualDiff,Float timeDiff,Float beat, ::math::Vector3 pos,int data,int player, ::flixel::FlxSprite obj){
            	HX_GC_STACKFRAME(&_hx_pos_771b475b1869cc73_49_getPos)
HXLINE(  50)		Float origin = this->modMgr->getBaseX(data,player);
HXDLIN(  50)		 ::math::Vector3 origin1 =  ::math::Vector3_obj::__alloc( HX_CTX ,origin,((( (Float)(::flixel::FlxG_obj::height) ) * ((Float)0.5)) - (::Note_obj::swagWidth * ((Float)0.5))),null());
HXLINE(  51)		if (::hx::IsNotNull( this->daOrigin )) {
HXLINE(  51)			origin1 = this->daOrigin;
            		}
HXLINE(  53)		 ::math::Vector3 result = null();
HXDLIN(  53)		if (::hx::IsNull( result )) {
HXLINE(  53)			result =  ::math::Vector3_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXDLIN(  53)		{
HXLINE(  53)			result->x = (pos->x - origin1->x);
HXDLIN(  53)			result->y = (pos->y - origin1->y);
HXDLIN(  53)			result->z = (pos->z - origin1->z);
            		}
HXDLIN(  53)		 ::math::Vector3 diff = result;
HXLINE(  54)		int scale = ::flixel::FlxG_obj::height;
HXLINE(  55)		 ::math::Vector3 diff1 = diff;
HXDLIN(  55)		diff1->z = (diff1->z * ( (Float)(scale) ));
HXLINE(  56)		Float out = this->getValue(player);
HXDLIN(  56)		Float out1 = this->getSubmodValue(((HX_("",00,00,00,00) + this->prefix) + HX_("rotateY",9e,49,1d,f1)),player);
HXDLIN(  56)		 ::math::Vector3 out2 = this->rotateV3(diff,out,out1,this->getSubmodValue(((HX_("",00,00,00,00) + this->prefix) + HX_("rotateZ",9f,49,1d,f1)),player));
HXLINE(  57)		 ::math::Vector3 out3 = out2;
HXDLIN(  57)		out3->z = (out3->z / ( (Float)(scale) ));
HXLINE(  58)		 ::math::Vector3 result1 = null();
HXDLIN(  58)		if (::hx::IsNull( result1 )) {
HXLINE(  58)			result1 =  ::math::Vector3_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXDLIN(  58)		{
HXLINE(  58)			result1->x = (origin1->x + out2->x);
HXDLIN(  58)			result1->y = (origin1->y + out2->y);
HXDLIN(  58)			result1->z = (origin1->z + out2->z);
            		}
HXDLIN(  58)		return result1;
            	}


::Array< ::String > RotateModifier_obj::getSubmods(){
            	HX_STACKFRAME(&_hx_pos_771b475b1869cc73_62_getSubmods)
HXDLIN(  62)		return ::Array_obj< ::String >::__new(2)->init(0,((HX_("",00,00,00,00) + this->prefix) + HX_("rotateY",9e,49,1d,f1)))->init(1,((HX_("",00,00,00,00) + this->prefix) + HX_("rotateZ",9f,49,1d,f1)));
            	}



::hx::ObjectPtr< RotateModifier_obj > RotateModifier_obj::__new( ::modchart::ModManager modMgr,::String __o_prefix, ::math::Vector3 origin, ::modchart::Modifier parent) {
	::hx::ObjectPtr< RotateModifier_obj > __this = new RotateModifier_obj();
	__this->__construct(modMgr,__o_prefix,origin,parent);
	return __this;
}

::hx::ObjectPtr< RotateModifier_obj > RotateModifier_obj::__alloc(::hx::Ctx *_hx_ctx, ::modchart::ModManager modMgr,::String __o_prefix, ::math::Vector3 origin, ::modchart::Modifier parent) {
	RotateModifier_obj *__this = (RotateModifier_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(RotateModifier_obj), true, "modchart.modifiers.RotateModifier"));
	*(void **)__this = RotateModifier_obj::_hx_vtable;
	__this->__construct(modMgr,__o_prefix,origin,parent);
	return __this;
}

RotateModifier_obj::RotateModifier_obj()
{
}

void RotateModifier_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(RotateModifier);
	HX_MARK_MEMBER_NAME(daOrigin,"daOrigin");
	HX_MARK_MEMBER_NAME(prefix,"prefix");
	 ::modchart::Modifier_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void RotateModifier_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(daOrigin,"daOrigin");
	HX_VISIT_MEMBER_NAME(prefix,"prefix");
	 ::modchart::Modifier_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val RotateModifier_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { return ::hx::Val( lerp_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"prefix") ) { return ::hx::Val( prefix ); }
		if (HX_FIELD_EQ(inName,"getPos") ) { return ::hx::Val( getPos_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return ::hx::Val( getName_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getOrder") ) { return ::hx::Val( getOrder_dyn() ); }
		if (HX_FIELD_EQ(inName,"daOrigin") ) { return ::hx::Val( daOrigin ); }
		if (HX_FIELD_EQ(inName,"rotateV3") ) { return ::hx::Val( rotateV3_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getSubmods") ) { return ::hx::Val( getSubmods_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val RotateModifier_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"prefix") ) { prefix=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"daOrigin") ) { daOrigin=inValue.Cast<  ::math::Vector3 >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void RotateModifier_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("daOrigin",43,21,ec,98));
	outFields->push(HX_("prefix",92,d9,b6,ae));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo RotateModifier_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::math::Vector3 */ ,(int)offsetof(RotateModifier_obj,daOrigin),HX_("daOrigin",43,21,ec,98)},
	{::hx::fsString,(int)offsetof(RotateModifier_obj,prefix),HX_("prefix",92,d9,b6,ae)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *RotateModifier_obj_sStaticStorageInfo = 0;
#endif

static ::String RotateModifier_obj_sMemberFields[] = {
	HX_("getName",01,22,82,1b),
	HX_("getOrder",18,00,f8,94),
	HX_("lerp",77,12,b0,47),
	HX_("daOrigin",43,21,ec,98),
	HX_("prefix",92,d9,b6,ae),
	HX_("rotateV3",38,1e,83,08),
	HX_("getPos",9e,96,24,a3),
	HX_("getSubmods",fb,c2,ec,7a),
	::String(null()) };

::hx::Class RotateModifier_obj::__mClass;

void RotateModifier_obj::__register()
{
	RotateModifier_obj _hx_dummy;
	RotateModifier_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.modifiers.RotateModifier",b6,cb,2b,81);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(RotateModifier_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< RotateModifier_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RotateModifier_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RotateModifier_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
} // end namespace modifiers
