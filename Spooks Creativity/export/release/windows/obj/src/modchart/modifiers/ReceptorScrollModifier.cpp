// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Conductor
#include <Conductor.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_Note
#include <Note.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_math_Vector3
#include <math/Vector3.h>
#endif
#ifndef INCLUDED_modchart_ModManager
#include <modchart/ModManager.h>
#endif
#ifndef INCLUDED_modchart_Modifier
#include <modchart/Modifier.h>
#endif
#ifndef INCLUDED_modchart_NoteModifier
#include <modchart/NoteModifier.h>
#endif
#ifndef INCLUDED_modchart_modifiers_ReceptorScrollModifier
#include <modchart/modifiers/ReceptorScrollModifier.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fd246c148604ed8c_9_new,"modchart.modifiers.ReceptorScrollModifier","new",0x86dc6336,"modchart.modifiers.ReceptorScrollModifier.new","modchart/modifiers/ReceptorScrollModifier.hx",9,0x6176ed78)
HX_LOCAL_STACK_FRAME(_hx_pos_fd246c148604ed8c_11_lerp,"modchart.modifiers.ReceptorScrollModifier","lerp",0x78a7fae1,"modchart.modifiers.ReceptorScrollModifier.lerp","modchart/modifiers/ReceptorScrollModifier.hx",11,0x6176ed78)
HX_LOCAL_STACK_FRAME(_hx_pos_fd246c148604ed8c_16_getName,"modchart.modifiers.ReceptorScrollModifier","getName",0x3e7bd7d7,"modchart.modifiers.ReceptorScrollModifier.getName","modchart/modifiers/ReceptorScrollModifier.hx",16,0x6176ed78)
HX_LOCAL_STACK_FRAME(_hx_pos_fd246c148604ed8c_19_getPos,"modchart.modifiers.ReceptorScrollModifier","getPos",0xf036ed88,"modchart.modifiers.ReceptorScrollModifier.getPos","modchart/modifiers/ReceptorScrollModifier.hx",19,0x6176ed78)
HX_LOCAL_STACK_FRAME(_hx_pos_fd246c148604ed8c_39_updateNote,"modchart.modifiers.ReceptorScrollModifier","updateNote",0x71781685,"modchart.modifiers.ReceptorScrollModifier.updateNote","modchart/modifiers/ReceptorScrollModifier.hx",39,0x6176ed78)
namespace modchart{
namespace modifiers{

void ReceptorScrollModifier_obj::__construct( ::modchart::ModManager modMgr, ::modchart::Modifier parent){
            	HX_STACKFRAME(&_hx_pos_fd246c148604ed8c_9_new)
HXLINE(  14)		this->moveSpeed = (::Conductor_obj::crochet * ( (Float)(3) ));
HXLINE(   9)		super::__construct(modMgr,parent);
            	}

Dynamic ReceptorScrollModifier_obj::__CreateEmpty() { return new ReceptorScrollModifier_obj; }

void *ReceptorScrollModifier_obj::_hx_vtable = 0;

Dynamic ReceptorScrollModifier_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ReceptorScrollModifier_obj > _hx_result = new ReceptorScrollModifier_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ReceptorScrollModifier_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1ed503bc) {
		if (inClassId<=(int)0x0ce062e5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0ce062e5;
		} else {
			return inClassId==(int)0x1ed503bc;
		}
	} else {
		return inClassId==(int)0x4386e937;
	}
}

Float ReceptorScrollModifier_obj::lerp(Float a,Float b,Float c){
            	HX_STACKFRAME(&_hx_pos_fd246c148604ed8c_11_lerp)
HXDLIN(  11)		return (a + ((b - a) * c));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ReceptorScrollModifier_obj,lerp,return )

::String ReceptorScrollModifier_obj::getName(){
            	HX_STACKFRAME(&_hx_pos_fd246c148604ed8c_16_getName)
HXDLIN(  16)		return HX_("receptorScroll",e9,08,48,fe);
            	}


 ::math::Vector3 ReceptorScrollModifier_obj::getPos(Float time,Float visualDiff,Float timeDiff,Float beat, ::math::Vector3 pos,int data,int player, ::flixel::FlxSprite obj){
            	HX_STACKFRAME(&_hx_pos_fd246c148604ed8c_19_getPos)
HXLINE(  20)		Float diff = timeDiff;
HXLINE(  21)		Float sPos = ::Conductor_obj::songPosition;
HXLINE(  22)		Float vDiff = (-((-(diff) - sPos)) / this->moveSpeed);
HXLINE(  23)		bool reversed = (::hx::Mod(::Math_obj::floor(vDiff),2) == 0);
HXLINE(  25)		Float startY = pos->y;
HXLINE(  26)		Float revPerc;
HXDLIN(  26)		if (reversed) {
HXLINE(  26)			revPerc = (( (Float)(1) ) - ::hx::Mod(vDiff,1));
            		}
            		else {
HXLINE(  26)			revPerc = ::hx::Mod(vDiff,1);
            		}
HXLINE(  28)		int upscrollOffset = 50;
HXLINE(  29)		int downscrollOffset = (::flixel::FlxG_obj::height - 150);
HXLINE(  31)		Float endY = (upscrollOffset + ((( (Float)(downscrollOffset) ) - (::Note_obj::swagWidth * ((Float)0.5))) * revPerc));
HXLINE(  33)		pos->y = (startY + ((endY - startY) * this->getValue(player)));
HXLINE(  35)		return pos;
            	}


void ReceptorScrollModifier_obj::updateNote(Float beat, ::Note daNote, ::math::Vector3 pos,int player){
            	HX_STACKFRAME(&_hx_pos_fd246c148604ed8c_39_updateNote)
HXLINE(  40)		if ((this->getValue(player) == 0)) {
HXLINE(  40)			return;
            		}
HXLINE(  41)		Float speed = (::PlayState_obj::instance->songSpeed * daNote->multSpeed);
HXLINE(  43)		Float timeDiff = (daNote->strumTime - ::Conductor_obj::songPosition);
HXLINE(  45)		Float diff = timeDiff;
HXLINE(  46)		Float sPos = ::Conductor_obj::songPosition;
HXLINE(  48)		Float songPos = (sPos / this->moveSpeed);
HXLINE(  49)		Float notePos = (-((-(diff) - sPos)) / this->moveSpeed);
HXLINE(  51)		if ((::Math_obj::floor(songPos) != ::Math_obj::floor(notePos))) {
HXLINE(  52)			 ::Note daNote1 = daNote;
HXDLIN(  52)			daNote1->alphaMod = (daNote1->alphaMod * ((Float).5));
HXLINE(  53)			daNote->zIndex++;
            		}
HXLINE(  55)		if (daNote->wasGoodHit) {
HXLINE(  55)			daNote->garbage = true;
            		}
            	}



::hx::ObjectPtr< ReceptorScrollModifier_obj > ReceptorScrollModifier_obj::__new( ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	::hx::ObjectPtr< ReceptorScrollModifier_obj > __this = new ReceptorScrollModifier_obj();
	__this->__construct(modMgr,parent);
	return __this;
}

::hx::ObjectPtr< ReceptorScrollModifier_obj > ReceptorScrollModifier_obj::__alloc(::hx::Ctx *_hx_ctx, ::modchart::ModManager modMgr, ::modchart::Modifier parent) {
	ReceptorScrollModifier_obj *__this = (ReceptorScrollModifier_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ReceptorScrollModifier_obj), true, "modchart.modifiers.ReceptorScrollModifier"));
	*(void **)__this = ReceptorScrollModifier_obj::_hx_vtable;
	__this->__construct(modMgr,parent);
	return __this;
}

ReceptorScrollModifier_obj::ReceptorScrollModifier_obj()
{
}

::hx::Val ReceptorScrollModifier_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { return ::hx::Val( lerp_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"getPos") ) { return ::hx::Val( getPos_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getName") ) { return ::hx::Val( getName_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"moveSpeed") ) { return ::hx::Val( moveSpeed ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"updateNote") ) { return ::hx::Val( updateNote_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ReceptorScrollModifier_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"moveSpeed") ) { moveSpeed=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ReceptorScrollModifier_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("moveSpeed",b6,66,30,3f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ReceptorScrollModifier_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ReceptorScrollModifier_obj,moveSpeed),HX_("moveSpeed",b6,66,30,3f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ReceptorScrollModifier_obj_sStaticStorageInfo = 0;
#endif

static ::String ReceptorScrollModifier_obj_sMemberFields[] = {
	HX_("lerp",77,12,b0,47),
	HX_("moveSpeed",b6,66,30,3f),
	HX_("getName",01,22,82,1b),
	HX_("getPos",9e,96,24,a3),
	HX_("updateNote",9b,02,bf,01),
	::String(null()) };

::hx::Class ReceptorScrollModifier_obj::__mClass;

void ReceptorScrollModifier_obj::__register()
{
	ReceptorScrollModifier_obj _hx_dummy;
	ReceptorScrollModifier_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("modchart.modifiers.ReceptorScrollModifier",44,50,f9,41);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ReceptorScrollModifier_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ReceptorScrollModifier_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ReceptorScrollModifier_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ReceptorScrollModifier_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace modchart
} // end namespace modifiers
