// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_shaders_OldTelevisionShader
#include <shaders/OldTelevisionShader.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9f02921f423365ce_131_new,"shaders.OldTelevisionShader","new",0xbd434230,"shaders.OldTelevisionShader.new","shaders/OldTelevision.hx",131,0xa94e7826)
namespace shaders{

void OldTelevisionShader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_9f02921f423365ce_131_new)
HXLINE( 182)		if (::hx::IsNull( this->_hx___glFragmentSource )) {
HXLINE( 184)			this->_hx___glFragmentSource = HX_("\r\n    varying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\t\tuniform sampler2D bitmap;\n\n\t\tuniform bool hasTransform;\n\t\tuniform bool hasColorTransform;\n\n\t\tvec4 flixel_texture2D(sampler2D bitmap, vec2 coord)\n\t\t{\n\t\t\tvec4 color = texture2D(bitmap, coord);\n\t\t\tif (!hasTransform)\n\t\t\t{\n\t\t\t\treturn color;\n\t\t\t}\n\n\t\t\tif (color.a == 0.0)\n\t\t\t{\n\t\t\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t}\n\n\t\t\tif (!hasColorTransform)\n\t\t\t{\n\t\t\t\treturn color * openfl_Alphav;\n\t\t\t}\n\n\t\t\tcolor = vec4(color.rgb / color.a, color.a);\n\n\t\t\tmat4 colorMultiplier = mat4(0);\n\t\t\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\n\t\t\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\n\t\t\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\n\t\t\tcolorMultiplier[3][3] = openfl_ColorMultiplierv.w;\n\n\t\t\tcolor = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\n\n\t\t\tif (color.a > 0.0)\n\t\t\t{\n\t\t\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\t\t\t}\n\t\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n\t\t}\n\t\n\r\n    uniform float iTime;\r\n   // uniform sampler2D noiseTex;\r\n    uniform vec3 iResolution;\r\n\r\n    float onOff(float a, float b, float c)\r\n    {\r\n        return step(c, sin(iTime + a*cos(iTime*b)));\r\n    }\r\n\r\n    float ramp(float y, float start, float end)\r\n    {\r\n        float inside = step(start,y) - step(end,y);\r\n        float fact = (y-start)/(end-start)*inside;\r\n        return (1.-fact) * inside;\r\n\r\n    }\r\n\r\n    vec4 getVideo(vec2 uv)\r\n      {\r\n        vec2 look = uv;\r\n            float window = 1./(1.+20.*(look.y-mod(iTime/4.,1.))*(look.y-mod(iTime/4.,1.)));\r\n            look.x = look.x + (sin(look.y*10. + iTime)/50.*onOff(4.,4.,.3)*(1.+cos(iTime*80.))*window)*(0*2);\r\n            float vShift = 0.4*onOff(2.,3.,.9)*(sin(iTime)*sin(iTime*20.) +\r\n                                                 (0.5 + 0.1*sin(iTime*200.)*cos(iTime)));\r\n            look.y = mod(look.y + vShift*0, 1.);\r\n        \r\n        vec4 video = flixel_texture2D(bitmap,look);\r\n\r\n        return video;\r\n      }\r\n\r\n    vec2 screenDistort(vec2 uv)\r\n    {\r\n        uv = (uv - 0.5) * 2.0;\r\n        uv *= 1.1;\r\n        uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\r\n        uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\r\n        uv  = (uv / 2.0) + 0.5;\r\n        uv =  uv *0.92 + 0.04;\r\n        return uv;\r\n      \r\n        return uv;\r\n    }\r\n    float random(vec2 uv)\r\n    {\r\n        return fract(sin(dot(uv, vec2(15.5151, 42.2561))) * 12341.14122 * sin(iTime * 0.03));\r\n    }\r\n    float noise(vec2 uv)\r\n    {\r\n        vec2 i = floor(uv);\r\n        vec2 f = fract(uv);\r\n\r\n        float a = random(i);\r\n        float b = random(i + vec2(1.,0.));\r\n        float c = random(i + vec2(0., 1.));\r\n        float d = random(i + vec2(1.));\r\n\r\n        vec2 u = smoothstep(0., 1., f);\r\n\r\n        return mix(a,b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y;\r\n\r\n    }\r\n\r\n\r\n    vec2 scandistort(vec2 uv) {\r\n        float scan1 = clamp(cos(uv.y * 2.0 + iTime), 0.0, 1.0);\r\n        float scan2 = clamp(cos(uv.y * 2.0 + iTime + 4.0) * 10.0, 0.0, 1.0) ;\r\n        float amount = scan1 * scan2 * uv.x;\r\n\r\n        //uv.x -= 0.05 * mix(flixel_texture2D(noiseTex, vec2(uv.x, amount)).r * amount, amount, 0.9);\r\n\r\n        return uv;\r\n\r\n    }\r\n    void main()\r\n    {\r\n        vec2 uv = openfl_TextureCoordv;\r\n      vec2 curUV = screenDistort(uv);\r\n        uv = scandistort(curUV);\r\n        vec4 video = getVideo(uv);\r\n      float vigAmt = 1.0;\r\n      float x =  0.;\r\n\r\n\r\n      video.r = getVideo(vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\r\n      video.g = getVideo(vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\r\n      video.b = getVideo(vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\r\n      video.r += 0.08*getVideo(0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\r\n      video.g += 0.05*getVideo(0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\r\n      video.b += 0.08*getVideo(0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\r\n\r\n      video = clamp(video*0.6+0.4*video*video*1.0,0.0,1.0);\r\n          vigAmt = 3.+.3*sin(iTime + 5.*cos(iTime*5.));\r\n\r\n        float vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\r\n\r\n         video *= vignette;\r\n\r\n\r\n      gl_FragColor = mix(video,vec4(noise(uv * 75.)),.05);\r\n\r\n      if(curUV.x<0 || curUV.x>1 || curUV.y<0 || curUV.y>1){\r\n        gl_FragColor = vec4(0,0,0,0);\r\n      }\r\n\r\n    }\r\n    ",24,c6,5a,47);
            		}
HXLINE( 174)		if (::hx::IsNull( this->_hx___glVertexSource )) {
HXLINE( 176)			this->_hx___glVertexSource = HX_("\n\t\tattribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\t\n\t\tattribute float alpha;\n\t\tattribute vec4 colorMultiplier;\n\t\tattribute vec4 colorOffset;\n\t\tuniform bool hasColorTransform;\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t\t\n\t\t\topenfl_Alphav = openfl_Alpha * alpha;\n\t\t\t\n\t\t\tif (hasColorTransform)\n\t\t\t{\n\t\t\t\topenfl_ColorOffsetv = colorOffset / 255.0;\n\t\t\t\topenfl_ColorMultiplierv = colorMultiplier;\n\t\t\t}\n\t\t}",f3,1e,fa,79);
            		}
HXLINE( 132)		super::__construct();
HXLINE(  19)		this->_hx___isGenerated = true;
HXDLIN(  19)		this->_hx___initGL();
            	}

Dynamic OldTelevisionShader_obj::__CreateEmpty() { return new OldTelevisionShader_obj; }

void *OldTelevisionShader_obj::_hx_vtable = 0;

Dynamic OldTelevisionShader_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< OldTelevisionShader_obj > _hx_result = new OldTelevisionShader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool OldTelevisionShader_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x11737abc) {
		if (inClassId<=(int)0x04f93fcd) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x04f93fcd;
		} else {
			return inClassId==(int)0x11737abc;
		}
	} else {
		return inClassId==(int)0x1efca5b6 || inClassId==(int)0x78d8d737;
	}
}


::hx::ObjectPtr< OldTelevisionShader_obj > OldTelevisionShader_obj::__new() {
	::hx::ObjectPtr< OldTelevisionShader_obj > __this = new OldTelevisionShader_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< OldTelevisionShader_obj > OldTelevisionShader_obj::__alloc(::hx::Ctx *_hx_ctx) {
	OldTelevisionShader_obj *__this = (OldTelevisionShader_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(OldTelevisionShader_obj), true, "shaders.OldTelevisionShader"));
	*(void **)__this = OldTelevisionShader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

OldTelevisionShader_obj::OldTelevisionShader_obj()
{
}

void OldTelevisionShader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(OldTelevisionShader);
	HX_MARK_MEMBER_NAME(iTime,"iTime");
	HX_MARK_MEMBER_NAME(noiseTex,"noiseTex");
	HX_MARK_MEMBER_NAME(iResolution,"iResolution");
	 ::flixel::graphics::tile::FlxGraphicsShader_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void OldTelevisionShader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(iTime,"iTime");
	HX_VISIT_MEMBER_NAME(noiseTex,"noiseTex");
	HX_VISIT_MEMBER_NAME(iResolution,"iResolution");
	 ::flixel::graphics::tile::FlxGraphicsShader_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val OldTelevisionShader_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"iTime") ) { return ::hx::Val( iTime ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noiseTex") ) { return ::hx::Val( noiseTex ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"iResolution") ) { return ::hx::Val( iResolution ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val OldTelevisionShader_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"iTime") ) { iTime=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noiseTex") ) { noiseTex=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"iResolution") ) { iResolution=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void OldTelevisionShader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("iTime",16,e1,e8,ac));
	outFields->push(HX_("noiseTex",6d,c2,0b,11));
	outFields->push(HX_("iResolution",f5,36,34,3f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo OldTelevisionShader_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(OldTelevisionShader_obj,iTime),HX_("iTime",16,e1,e8,ac)},
	{::hx::fsObject /*  ::openfl::display::ShaderInput_openfl_display_BitmapData */ ,(int)offsetof(OldTelevisionShader_obj,noiseTex),HX_("noiseTex",6d,c2,0b,11)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(OldTelevisionShader_obj,iResolution),HX_("iResolution",f5,36,34,3f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *OldTelevisionShader_obj_sStaticStorageInfo = 0;
#endif

static ::String OldTelevisionShader_obj_sMemberFields[] = {
	HX_("iTime",16,e1,e8,ac),
	HX_("noiseTex",6d,c2,0b,11),
	HX_("iResolution",f5,36,34,3f),
	::String(null()) };

::hx::Class OldTelevisionShader_obj::__mClass;

void OldTelevisionShader_obj::__register()
{
	OldTelevisionShader_obj _hx_dummy;
	OldTelevisionShader_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("shaders.OldTelevisionShader",3e,aa,12,5c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(OldTelevisionShader_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< OldTelevisionShader_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OldTelevisionShader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OldTelevisionShader_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace shaders
